== Pagination tips and recommendations

The pagination of search results can be done using the 'from' and 'size' parameters in the search request. But as the search gets into deeper pages, it starts consuming more resources.  

To safeguard against any arbitrary higher memory requirements, FTS provides a configurable limit bleveMaxResultWindow (10000 default) on the maximum allowable page offsets. However, bumping this limit to higher levels is not a scalable solution.

To circumvent this problem, the concept of key set pagination in FTS, is introduced. 

Instead of providing _from_ as a number of search results to skip, the user will provide the sort value of a previously seen search result (usually, the last result shown on the current page).  The idea is that to show the next page of the results, we just want the top N results of that sort after the last result from the previous page.

This solution requires a few preconditions be met:

** The search request must specify a sort order.
** The sort order must impose a total order on the results.  Without this, any results which share the same sort value might be left out when handling the page navigation boundaries.  

A common solution to this is to always include the document ID as the final sort criteria.                                       

For example, if you want to sort by [“name”, “-age”], instead of sort by [“name”, “-age”, “_id”].

With search_after/search_before paginations, the heap memory requirement of deeper page searches is made proportional to the requested page size alone. So it reduces the heap memory requirement of deeper page searches significantly down from the offset+from values.

== Example

User searches for description: light and sorts by [“name”, “_id”]

{

  "query": {
    "query": "description:flight"
  },
  "sort": [
    "name",
    "_id"
  ],
  "search_before": [
    "Anchor USA Flights",
    "anchor_timings_for_usa_flights"
  ],
  "search_after": [
    "Anchor Hotel Landmarks",
    "anchor_location_of_hotels"
  ]

}


