= Types of Queries

== Simple Queries

[[match-query]]Match Query::
A match query analyzes the input text and uses that analyzed text to query the index.
An attempt is made to use the same analyzer that was used when the field was indexed.
+
The match query can optionally perform fuzzy matching.
If the fuzziness parameter is set to a non-zero integer the analyzed text will be matched with the specified level of fuzziness.
Also, the [.param]`prefix_length` parameter can be used to specify that the term is also required to have the same prefix of the specified length.

[[match-phrase-query]]Match Phrase Query::
The input text is analyzed and a phrase query is built with the terms resulting from the analysis.
This type of query searches for terms occurring in the specified positions and offsets.
This depends on term vectors, which are consulted to determine phrase distance.
+
Although this is not an exact match, it is usually the search behavior users want.
+
For example, a match phrase query for "location for functions" might match "locate the function" if the standard `en` analyzer is used.
This is because the stemmer tokenizes "location" and "locate" to "locati", and "functions" and "function" to "function." Stop word removal will remove "for" and "the" but the distance between the tokens will be the same.

Fuzzy Query::
A fuzzy query is a term query that matches terms within a specified edit distance (Levenshtein distance).
Also, you can optionally specify that the term must have a matching prefix of the specified length.

Prefix Query:: The prefix query finds documents containing terms that start with the provided prefix.

Regexp Query:: Regexp query finds documents containing terms that match the specified regular expression.

Wildcard Query::
The wildcard query uses a wildcard expression to search within individual terms for matches.
Wildcard expressions can be any single character (?) or zero to many characters (*).
Wildcard expressions can appear in the middle or end of a term but not at the beginning of the search term.

Boolean Field Query::
The Boolean field query searches a field that contains Boolean true or false values.
A Boolean field query searches the actual content of the field, and should not be confused with the <<boolean-query,Boolean queries>> (described in the section on compound queries) that modify whether a query  must, should, or must not be present.

== Compound Queries

Conjunction Query::
The conjunction query is a compound query.
The result documents must satisfy all of the child queries.

Disjunction Query::
The disjunction query is a compound query.
The result documents must satisfy a configurable [.in]`min` number of child queries.
By default this `min` is set to 1.

[[boolean-query]]Boolean Query::
The boolean query is a useful combination of conjunction and disjunction queries.
A boolean query takes three lists of queries:
* must - result documents must satisfy all of these queries.
* should - result documents should satisfy these queries.
* must not - result documents must not satisfy any of these queries.

Doc ID Query::
The doc ID query returns the indexed document or documents among the specified set.
This is typically used in conjunction queries to restrict the scope of other queries’ output.

== Range Queries

Date Range Query::
The date range query finds documents containing a date value in the specified field within the specified range.
Define the endpoints using the fields [.param]`start`  and [.param]`end`.
You can omit one endpoint, but not both.
The [.param]`inclusiveStart` and [.param]`inclusiveEnd` properties in the query JSON control whether or not the end points are included or excluded.

Numeric Range Query::
The numeric range query finds documents containing a numeric value in the specified field within the specified range.
Define the endpoints using the fields [.param]`min`  and [.param]`max`.
You can omit one endpoint, but not both.
The [.param]`inclusiveMin` and [.param]`inclusiveMax` properties control whether or not the end points are included or excluded.
By default, [.param]`min` is inclusive and [.param]`max` is exclusive.

[#query-string-query-syntax]
== Query String Query

Also known as the String Query, the query string query allows humans to describe complex queries using a simple syntax.
When you search a full text index with the Web Console, you use this query syntax.

NOTE: Certain queries that are supported by FTS are not yet supported by the query string syntax.
This includes wildcards, regexp, and date range queries.

Match::
A term without any other syntax is interpreted as a match query for the term in the default field.
The default field is `_all` unless overridden in the index mapping.
+
Example: `water` performs a <<match-query,Match Query>> for the term "water".

Match Phrases::
Placing the search terms in quotes performs a match phrase query.
This is not an exact match, see <<match-phrase-query,Match Phrases Query>> for more information.
+
Example: "[.in]``light beer``" performs a <<match-phrase-query,Match Phrases Query>> for the phrase "[.code]``light beer``".

Field Scoping::
You can qualify the field for these searches by prefixing them with the name of the field separated by a colon.
+
Example: [.in]`description:water` performs a <<match-query,Match Query>> for the term "[.code]``water``", in the `description` field.

Required, Optional, and Exclusion::
When your query string includes multiple items, by default these are placed into the SHOULD clause of a http://www.blevesearch.com/docs/Query/#boolean:8f767fbc41af8ff1ddcf4c60ed8c0fe9[Boolean Query^].
+
You can change this by prefixing your items with a `+` or ‘`-`’`.` `*` ‘`+`’ Prefixing with plus places that item in the MUST portion of the boolean query.
`*` ‘`-`’ Prefixing with a minus places that item in the MUST NOT portion of the boolean query.
+
Example: `+description:water -light beer` will perform a boolean query that MUST satisfy the match query for the term "[.code]``water``" in the description field, MUST NOT satisfy the match query for the term "[.code]``light``" in the default field, and SHOULD satisfy the match query for the term "[.code]``beer``" in the default field.
Result documents satisfying the SHOULD clause will score higher than those that do not.

Boosting::
You can influence the relative importance of the clauses by suffixing clauses with the `^` operator followed by a number.
+
Example: `description:water name:water^5` will perform match queries for "[.code]``water``" in both the `name` and `description` fields, but documents having the term in the `name` field will score higher.

Numeric Ranges::
You can perform numeric ranges by using the >, >=, <, and \<= operators, followed by a numeric value.
+
Example: `abv:>10` will perform an Numeric Range Query on the `abv` field for values greater than ten.

== Special Queries

Special queries are usually used in combination with other queries or used to test the systems.

Match All Query::
Matches all documents in the index.
Be aware that this query will match all documents that were indexed even if they have no terms in the index.
For example, if a custom map is created on the travel-sample bucket that indexes documents of type="zucchini", the match all query returns all document IDs in the bucket even though there are no documents of type="zucchini".
This can be very counter-intuitive.

Match None Query:: Matches no documents in the index.

== Queries for Debugging

Term and Phrase queries do not perform any analysis on their inputs.
This is useful for debugging exactly what is in an index, but this is rarely used otherwise.
Typically, users want match and phrase match queries.

In the normal case, an analyzer is used on both the text to be indexed and the query terms.
Because the terms in the index have usually been run through an analyzer and a stemmer, they often no longer look like normal language.
End users of search systems never see the stored terms but because their queries are also run through the same analyzer, the results match.

Basically, a user who is going to do a term or phrase search already has to know all of this when they select that type of search, because they aren’t entering normal words, they might be entering weird non-words like "natio" or "beaut" instead of queries like "National" or "beauties"

Term Query::
A term query is the simplest possible query.
It performs an exact match in the index for the provided term.
Most of the time users should use a Match Query instead.
+
For example, a term query for "lovingli" would match documents with the term "lovingly" if they were indexed with the "[.code]``en``" analyzer.
A term query for the  "lovingly" won’t match any documents that were indexed with the "[.code]``en``" analyzer.

Phrase Query::
A phrase query searches for terms occurring in the specified position and offsets.
+
The phrase query performs an exact term match for all the phrase constituents without using an analyzer.
If you want the phrase to be analyzed, consider using the Match Phrase Query instead.
