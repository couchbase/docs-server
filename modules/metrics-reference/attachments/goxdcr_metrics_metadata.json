{
  "xdcr_add_docs_cas_changed_total": {
    "added": "7.0.0",
    "help": "Number of Add operations that failed because the CAS on the Target changed",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "internal",
    "type": "counter"
  },
  "xdcr_add_docs_written_total": {
    "added": "7.0.0",
    "help": "Number of Add operations successfully written to the Target",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "notes": "This means that the Target did not have the Source Document by name prior to this operation",
    "stability": "internal",
    "type": "counter"
  },
  "xdcr_add_failed_cr_target_total": {
    "added": "7.1.0",
    "help": "Number of Add operations failed Conflict Resolution at the Target",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "internal",
    "type": "counter"
  },
  "xdcr_atr_txn_docs_filtered_total": {
    "added": "7.6.0",
    "help": "Total number of documents filtered and not replicated because the documents were ATR documents",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_binary_filtered_total": {
    "added": "7.2.1",
    "help": "Number of documents filtered that were binary documents",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_changes_left_total": {
    "added": "7.0.0",
    "help": "Given the vBuckets of this node, the number of sequence numbers that need to be processed (either replicated or handled) before catching up to the high sequence numbers for the vBuckets",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "notes": "This metric is calculated as (totalChanges - docsProcessed).  TotalChanges is calculated as: SumForEachVB(HighSeqno) that this node owns.The term 'changes' is more of a misnomer as it is still defined as each mutation or event that gets stamped with a sequence number. Since 7.0, system events also get stamped as a seqno per VB and thus the changes_left term no longer accurately represents actual mutations that needs to be replicated. Regardless, this number represents the concept of how much work is to be done before a replication is considered caught up.",
    "stability": "committed",
    "type": "gauge",
    "uiName": "xdcr_changes_left_total"
  },
  "xdcr_client_txn_docs_filtered_total": {
    "added": "7.6.0",
    "help": "Total number of documents filtered and not replicated because the documents were transaction client records",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_data_merge_failed_bytes": {
    "added": "7.0.0",
    "help": "Amount of data failed to merge as part of Source custom conflict-resolution",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "internal",
    "type": "counter",
    "unit": "bytes"
  },
  "xdcr_data_merged_bytes": {
    "added": "7.0.0",
    "help": "Amount of data merged for a Replication when performing Source custom conflict-resolution",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "internal",
    "type": "counter",
    "unit": "bytes"
  },
  "xdcr_data_replicated_bytes": {
    "added": "7.0.0",
    "help": "Amount of data replicated for a Replication",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "committed",
    "type": "counter",
    "uiName": "xdcr_data_replicated_bytes",
    "unit": "bytes"
  },
  "xdcr_data_replicated_uncompress_bytes": {
    "added": "7.6.0",
    "help": "Theoretical amount of data replicated for a Replication if compression were not used",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "notes": "This stat is used in conjunction with data_replicated such that compression ratios can be calculated",
    "stability": "committed",
    "type": "counter",
    "unit": "bytes"
  },
  "xdcr_datapool_failed_gets_total": {
    "added": "7.0.0",
    "help": "The total number of failed GET() operation on a reusable datapool within XDCR for the purpose of avoiding garbage generation",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "notes": "This stats usually should be 0. If it is non-0, it could represent that the memory is under pressure.",
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_dcp_datach_length_total": {
    "added": "7.0.0",
    "help": "The number of items sent by the Data Service waiting for the XDCR Source Nozzle to ingest and process",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "committed",
    "type": "gauge"
  },
  "xdcr_dcp_dispatch_time_seconds": {
    "added": "7.0.0",
    "help": "The rolling average amount of time it takes for a document to be received by XDCR from the Data Service, to the time it is queued up in the Target Nozzle ready to be sent",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "committed",
    "type": "gauge",
    "unit": "seconds"
  },
  "xdcr_deletion_cloned_total": {
    "added": "7.2.1",
    "help": "The number of times a Source Deletion or Expiration is cloned to be written to multiple Target Namespaces",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "notes": "This usually happens in collection migration using explicit rule-based mapping where Deletions and Expirations will pass all rules.",
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_deletion_docs_cas_changed_total": {
    "added": "7.0.0",
    "help": "Number of Deletions failed because Target CAS changed",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "internal",
    "type": "counter"
  },
  "xdcr_deletion_docs_written_total": {
    "added": "7.0.0",
    "help": "Number of Deletions written to Target",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_deletion_failed_cr_source_total": {
    "added": "7.0.0",
    "help": "Number of Deletions that failed Source-side Conflict Resolution",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_deletion_failed_cr_target_total": {
    "added": "7.1.0",
    "help": "Number of Deletions that failed Conflict Resolution at the Target",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_deletion_filtered_total": {
    "added": "7.0.0",
    "help": "Number of Deletions that were filtered Source-side",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_deletion_received_from_dcp_total": {
    "added": "7.0.0",
    "help": "Number of Deletions received from the Data Service",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_deletion_target_docs_skipped_total": {
    "added": "7.0.0",
    "help": "Subset of the number of documents that originated from the target that were delete operations",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "internal",
    "type": "counter"
  },
  "xdcr_docs_checked_total": {
    "added": "7.0.0",
    "help": "Across vBuckets for this node, the sum of all sequence numbers that have been considered to be checkpointed",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "notes": "This metric is often used in conjunction with docs_processed. The wider the difference means the more duplicate replication would take place if a replication pipeline were to restart, as it means less information is checkpointed",
    "stability": "committed",
    "type": "gauge",
    "uiName": "xdcr_docs_checked_total"
  },
  "xdcr_docs_cloned_total": {
    "added": "7.0.0",
    "help": "Number of Source Document Mutation cloned to be written to different Target Namespaces",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "notes": "This usually means that one source mutation is now going to exist in two or more target collections, leading to mismatching doc counts between buckets. This can happen when migration mode is turned on, and the migration filtering expression is not specific enough, leading to a single doc matching multiple migration filtering expressions. To prevent this, ensure that the filtering expr are more specific such that each doc is migrated to only one target collection.",
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_docs_failed_cr_source_total": {
    "added": "7.0.0",
    "help": "Number of documents (or tombstones) that were not replicated to the Target due to Conflict Resolution evaluated on the Source",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "notes": "This metric contains all types of docs that were not successfully sent to target due to failed CR, including deletions and expiries. It is also possible that a source document could fail CR due to a tombstone that exists in the target bucket. In that case, it may look like that a document is not replicated to the target, but in fact it is because target contains a tombstone that causes source CR to lose. Vice versa, it is possible that a deletion on the source could lose, and the target document continues to exist even though the source counterpart does not.",
    "stability": "committed",
    "type": "counter",
    "uiName": "xdcr_docs_failed_cr_source_total"
  },
  "xdcr_docs_failed_cr_target_total": {
    "added": "7.1.0",
    "help": "Number of documents failed Conflict Resolution at the Target",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "notes": "This metric contains all types of docs that were replicated to the target but were ultimately rejected due to target side conflict-resolution. This can happen either due to optimistic replication or due to other actors that are mutating the same document on the target bucket even if source CR succeeded.",
    "stability": "committed",
    "type": "counter",
    "uiName": "xdcr_docs_failed_cr_target_total"
  },
  "xdcr_docs_filtered_on_txn_xattr_total": {
    "added": "7.6.0",
    "help": "Total number of documents filtered and not replicated due to the presence of transaction related xattrs in it",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_docs_filtered_on_user_defined_filter_total": {
    "added": "7.6.0",
    "help": "Total number of documents filtered and not replicated because of user defined filter expressions",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_docs_filtered_total": {
    "added": "7.0.0",
    "help": "Total number of documents filtered and not replicated due to any type of filtering",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "committed",
    "type": "gauge",
    "uiName": "xdcr_docs_filtered_total"
  },
  "xdcr_docs_merge_cas_changed_total": {
    "added": "7.0.0",
    "help": "Number of documents from Source custom conflict-resolution that failed to merge back to Source because the Source CAS changed",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "internal",
    "type": "counter"
  },
  "xdcr_docs_merge_failed_total": {
    "added": "7.0.0",
    "help": "Number of conflicting docs failed to merge as part of Source custom conflict-resolution",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "internal",
    "type": "counter"
  },
  "xdcr_docs_merged_total": {
    "added": "7.0.0",
    "help": "Number of conflicting docs successfully merged and written to the Source after performing Source custom conflict-resolution",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "internal",
    "type": "counter"
  },
  "xdcr_docs_opt_repd_total": {
    "added": "7.0.0",
    "help": "Number of Documents Optimistically Replicated to the Target Cluster",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "notes": "Optimistic Replication takes one less round trip on the network, but could potentially cause more network usage if the documents are reasonably sized",
    "stability": "committed",
    "type": "counter",
    "uiName": "xdcr_docs_opt_repd_total"
  },
  "xdcr_docs_processed_total": {
    "added": "7.0.0",
    "help": "Number of Documents processed for a Replication",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "notes": "Each Document is considered to be a single Mutation or event tagged with a Sequence Number. It is considered processed when a Mutation is either Replicated to the Target Cluster, or not replicated due to a decision made, such as a document being filtered, or if it loses Source Conflict Resolution. Another example can be a system event such as a Collection creation that gets its own Sequence Number, but is not actually something that can be replicated. These are also counted as a doc being processed.",
    "stability": "committed",
    "type": "gauge"
  },
  "xdcr_docs_received_from_dcp_total": {
    "added": "7.0.0",
    "help": "Number of Document Mutations received from the Data Service",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "committed",
    "type": "counter",
    "uiName": "xdcr_docs_received_from_dcp_total"
  },
  "xdcr_docs_unable_to_filter_total": {
    "added": "7.0.0",
    "help": "Number of Document Mutations that couldn't be filtered due to inability to parse the document through Advanced Filtering engine and were not replicated",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "committed",
    "type": "gauge"
  },
  "xdcr_docs_written_total": {
    "added": "7.0.0",
    "help": "Number of docs Document Mutations written/sent to the Target",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "notes": "This metric counts any type of mutations that are sent to the target cluster, and includes mutations that had failed target side Conflict Resolution",
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_expiry_docs_merge_failed_total": {
    "added": "7.0.0",
    "help": "Number of conflicting expiry docs failed to merge as part of Source custom conflict-resolution",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "internal",
    "type": "counter"
  },
  "xdcr_expiry_docs_merged_total": {
    "added": "7.0.0",
    "help": "Number of Expirations merged and written to the Source",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "internal",
    "type": "counter"
  },
  "xdcr_expiry_docs_written_total": {
    "added": "7.0.0",
    "help": "Number of Expirations written to the Target",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_expiry_failed_cr_source_total": {
    "added": "7.0.0",
    "help": "Number of Expirations that failed Source-side Conflict Resolution",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_expiry_failed_cr_target_total": {
    "added": "7.1.0",
    "help": "Number of Expirations that failed Conflict Resolution at the Target",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "volatile",
    "type": "counter"
  },
  "xdcr_expiry_filtered_total": {
    "added": "7.0.0",
    "help": "Number of Expirations filtered Source-side",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_expiry_merge_cas_changed_total": {
    "added": "7.0.0",
    "help": "Number of expiry from Source custom conflict-resolution that failed to merge back to Source because the Source CAS changed",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "internal",
    "type": "counter"
  },
  "xdcr_expiry_received_from_dcp_total": {
    "added": "7.0.0",
    "help": "Number of Expirations or documents with TTL received from the Data Service",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_expiry_stripped_total": {
    "added": "7.0.0",
    "help": "Number of Document Mutations replicated that had the TTL changed to 0 before writing to Target (Source is unmodified)",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "notes": "The source has an expiry set and the target does not. When the source document expires, it will trigger a expiry event that should be replicated to the target. If that expiry event is not replicated for any reason and is purged (i.e. tombstone purge interval), then the target doucment will contiue to live for perpetuity. If the purpose is for archival such that the target should live for perpetuity, then it is adv filter for expiry should also be set, but will cause document count divergence",
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_expiry_target_docs_skipped_total": {
    "added": "7.0.0",
    "help": "Subset of the number of Document Mutations that originated from the Target that specifically had Expiry flag set",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "internal",
    "type": "counter"
  },
  "xdcr_guardrail_data_size_total": {
    "added": "7.6.0",
    "help": "The number of writes that target rejected because each target data node is holding too much data",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "notes": "When target bucket has guardrail enabled and a threshold set, it will return this error indicating that the target data nodes are holding too much data per node, which could lead to rebalance failures or cluster instability. To resume replication, additional data nodes must be added",
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_guardrail_disk_space_total": {
    "added": "7.6.0",
    "help": "The number of writes that target rejected because a data node is running out of disk space",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "notes": "When target bucket has guardrail enabled and a threshold set, it will return this error indicating that one or more data nodes is running out of disk space. To resume replication, additional disk storage must be added",
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_guardrail_resident_ratio_total": {
    "added": "7.6.0",
    "help": "The number of writes that target rejected due to the target bucket being under the resident ratio threshold",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "notes": "When target bucket has guardrail enabled and a threshold set, it will return this error indicating that the bucket is currently below the resident ratio. Data writes can only continue once the target bucket's resident ratio rises above the threshold",
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_mobile_docs_filtered_total": {
    "added": "7.6.0",
    "help": "Total number of documents filtered and not replicated because the documents were mobile records",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_num_checkpoints_total": {
    "added": "7.0.0",
    "help": "The number of times checkpoint operation has completed successfully since this XDCR process instance is made aware of this replication",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_num_failedckpts_total": {
    "added": "7.0.0",
    "help": "The number of times checkpoint operation has encountered an error since this XDCR process instance is made aware of this replication",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_pipeline_errors": {
    "added": "7.2.1",
    "help": "The number of currently present errors for a specific Replication Pipeline",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "notes": "If the number is non zero, it could indicate potential replication errors that requires some human intervention to look into the UI console or logs to decipher what errors could currently exist.",
    "stability": "committed",
    "type": "gauge"
  },
  "xdcr_pipeline_status": {
    "added": "7.2.1",
    "help": "The pipeline status for a specific pipeline, where it could be paused, running or, error",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType",
      "status"
    ],
    "notes": "A set of stats that represents the state of a pipeline, whether or not it is running or manually paused, or is in a erroneous state",
    "stability": "committed",
    "type": "gauge"
  },
  "xdcr_resp_wait_time_seconds": {
    "added": "7.0.0",
    "help": "The rolling average amount of time it takes from when a MemcachedRequest is created to be ready to route to an outnozzle to the time that the response has been heard back from the target node after a successful write",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "notes": "This metric indicates just the amount of wait time it takes for data service to send a respond back to XDCR as part of the complete docs_latency metrics. This can be used to give more granularity into how the overall latency situation looks like.",
    "stability": "committed",
    "type": "gauge",
    "unit": "seconds"
  },
  "xdcr_seqno_adv_received_from_dcp_total": {
    "added": "7.6.0",
    "help": "The number of seqno advance events received from source data service",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "notes": "These events are sent down from source data service and counted as a processed document in statistics, but are not actually replicable data",
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_set_docs_cas_changed_total": {
    "added": "7.0.0",
    "help": "Number of Set operations that failed because the CAS on the Target changed",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "internal",
    "type": "counter"
  },
  "xdcr_set_docs_written_total": {
    "added": "7.0.0",
    "help": "Number of Set operations successfully written to the Target",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_set_failed_cr_source_total": {
    "added": "7.0.0",
    "help": "Number of Set operations that failed Source-side Conflict Resolution",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "internal",
    "type": "counter"
  },
  "xdcr_set_failed_cr_target_total": {
    "added": "7.1.0",
    "help": "Number of Set operations that failed Conflict Resolution at the Target",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "volatile",
    "type": "counter"
  },
  "xdcr_set_filtered_total": {
    "added": "7.0.0",
    "help": "Number of documents filtered that was of a DCP mutation",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_set_received_from_dcp_total": {
    "added": "7.0.0",
    "help": "Number of Sets received from the Data Service",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_set_target_docs_skipped_total": {
    "added": "7.0.0",
    "help": "Subset of the number of documents that originated from the target that were set operations",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "internal",
    "type": "counter"
  },
  "xdcr_size_rep_queue_bytes": {
    "added": "7.0.0",
    "help": "Amount of data being queued to be sent in a Target Nozzle",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "notes": "The larger the amount of data being buffered to be sent will cause the goxdcr process to take up more memory.  If too much memory is being used, consider decreasing the number of nozzles or tune such that less data will be buffered",
    "stability": "committed",
    "type": "gauge",
    "unit": "bytes"
  },
  "xdcr_system_events_received_from_dcp_total": {
    "added": "7.6.0",
    "help": "The number of system events received from source data service",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "notes": "These events are sent down from source data service and counted as a processed document in statistics such as collection creation events, but are not actually replicable data",
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_target_docs_skipped_total": {
    "added": "7.0.0",
    "help": "Number of Document Mutations that were not replicated to the Target because they originated from the Target",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "internal",
    "type": "counter"
  },
  "xdcr_target_eaccess_total": {
    "added": "7.2.1",
    "help": "The total number of EACCESS errors returned from the target node.",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_target_tmpfail_total": {
    "added": "7.2.1",
    "help": "The total number of TMPFAIL errors returned from the target node.",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_target_unknown_status_total": {
    "added": "7.6.0",
    "help": "The total number of writes to target data service that returned with a status code that XDCR cannot comprehend",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "committed",
    "type": "counter"
  },
  "xdcr_throttle_latency_seconds": {
    "added": "7.0.0",
    "help": "The rolling average of the latency time introduced due to bandwith throttler",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "committed",
    "type": "gauge",
    "unit": "seconds"
  },
  "xdcr_throughput_throttle_latency_seconds": {
    "added": "7.0.0",
    "help": "The rolling average of the latency time introduced due to throughput throttler",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "committed",
    "type": "gauge",
    "unit": "seconds"
  },
  "xdcr_time_committing_seconds": {
    "added": "7.0.0",
    "help": "The rolling average amount of time it takes for a checkpoint operation to complete",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "notes": "The higher the number, the more burdened XDCR is or the slower the performance of simple_store (metakv)",
    "stability": "committed",
    "type": "gauge",
    "unit": "seconds"
  },
  "xdcr_wtavg_docs_latency_seconds": {
    "added": "7.0.0",
    "help": "The rolling average amount of time it takes for the source cluster to receive the acknowledgement of a SET_WITH_META response after the Memcached request has been composed to be processed by the XDCR Target Nozzle",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "notes": "This metric indicates the lag time of both the network as well as the target Key-Value set latency. The latency tracks the followings: 1. The time it takes to issue a SET_WITH_META from the source to the target. 2. The time it takes for data service to handle the SET_WITH_META request. 3. The time it takes for data service to send a response back to XDCR indicating that a SET_WITH_META has been handled. When combined with traditional network diagnostic tools, one can use this number to differentiate between the network latency as well as target data service latency.",
    "stability": "committed",
    "type": "gauge",
    "uiName": "xdcr_wtavg_docs_latency_seconds",
    "unit": "seconds"
  },
  "xdcr_wtavg_get_doc_latency_seconds": {
    "added": "7.0.0",
    "help": "The rolling average amount of time it takes once a get document command is composed to be sent to the time the request is handled once the target node has responded",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "internal",
    "type": "gauge",
    "unit": "seconds"
  },
  "xdcr_wtavg_merge_latency_seconds": {
    "added": "7.0.0",
    "help": "The rolling average amount of time it takes from routing, conflict detection and resolution, to receive the acknowledgement of merge",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "stability": "internal",
    "type": "gauge",
    "unit": "seconds"
  },
  "xdcr_wtavg_meta_latency_seconds": {
    "added": "7.0.0",
    "help": "The rolling average amount of time it takes once a getMeta command is composed to be sent to the time the request is handled once the target node has responded",
    "labels": [
      "sourceBucketName",
      "targetClusterUUID",
      "targetBucketName",
      "pipelineType"
    ],
    "notes": "This is similar to docs_latency but specifically for the GET_META command that is used for source side conflict resolution",
    "stability": "committed",
    "type": "gauge",
    "uiName": "xdcr_wtavg_meta_latency_seconds",
    "unit": "seconds"
  }
}
