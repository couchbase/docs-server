[#concept_yzq_ktc_np]
= MERGE

A MERGE statement provides the ability to update, insert into, or delete from a keyspace based on the results of a join with another keyspace or subquery.
It is possible to specify actions (insert, update, delete) on the keyspace based a match or no match in the join.
Multiple actions can be specified in the same query.

_merge:_

----
MERGE INTO keyspace-ref USING merge-source ON key-clause merge-actions [limit-clause] [returning-clause]
----

_merge-source:_

----
[from-path] ( [AS] [alias] | ( select ) [AS] alias
----

_keys-clause:_

----
[PRIMARY] KEY expression
----

_merge-actions:_

----
 [merge-update] [merge-delete] [merge-insert]
----

_merge-update:_

----
WHEN MATCHED THEN UPDATE [set-clause] [unset-clause] [where-clause]
----

_merge-delete:_

----
WHEN MATCHED THEN DELETE [where-clause]
----

_merge-insert:_

----
WHEN NOT MATCHED THEN INSERT expression [where-clause]
----

*RBAC Privileges*

User executing the MERGE statement must have the following privileges:

[#ul_jml_fdp_4z]
* _Query Select_ privileges on the source keyspace
* _Query Insert_, _Query Update_, or _Query Delete_ privileges on the target keyspace as per the MERGE actions
* _Query Select_ privileges on the keyspaces referred in the RETURNING clause

For more details about user roles, see xref:security:security-authorization.adoc#authorization[Authorization].

For example,

----
MERGE INTO `travel-sample` t 
USING [{"id":"21728"},{"id":"21730"}] source
ON KEY "hotel_"|| source.id
WHEN MATCHED THEN UPDATE SET t.old_vacancy = t.vacancy, t.vacancy = false 
RETURNING meta(t).id, t.old_vacancy, t.vacancy;
----

*Examples*

The following statement updates product based on orders.

----
MERGE INTO product p USING orders o ON KEY o.productId
WHEN MATCHED THEN
     UPDATE SET p.lastSaleDate = o.orderDate
WHEN MATCHED THEN
     DELETE WHERE p.inventoryCount  <= 0
----

The following statement merges two datasets containing employee information.
It then updates all_empts on match with emps_deptb and inserts when there is no match.

----
MERGE INTO all_empts a USING emps_deptb b ON KEY b.empId
WHEN MATCHED THEN
     UPDATE SET a.depts = a.depts + 1
     a.title = b.title || ", " || b.title
WHEN NOT MATCHED THEN
     INSERT  { "name": b.name, "title": b.title, "depts": b.depts, "empId": b.empId, "dob": b.dob }
----
