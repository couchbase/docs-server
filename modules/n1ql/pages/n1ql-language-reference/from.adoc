= FROM clause
:page-status: Couchbase Server 4.0
:imagesdir: ../../assets/images

[abstract]
The `FROM` clause specifies the keyspaces and JOIN operations on them.

== Purpose

In a `SELECT` query or subquery, the `FROM` clause specifies one or more of the following:

* Keyspaces
* Subqueries (such as derived tables)
* JOIN clauses
* JOIN conditions
* Expressions (nested collections, `CURL()`, or other expressions)

== Prerequisites

For you to select data from keyspace or expression, you must have the [.param]`query_select` privilege on that keyspace.
For more details about user roles, see
xref:learn:security/authorization-overview.adoc[Authorization].

== Syntax

image::n1ql-language-reference/from-term.png[]

----
FROM from-keyspace [ [ AS ] alias1 ] [ USE KEYS use-clause ]
                    | "(" SELECT ")" [ [ AS ] alias2 ]
                    | expr [ [ AS ] alias3 ]
                    | from-term ( join-clause | nest-clause | unnest-clause )
----

from-clause ::= 'FROM' from-term

=== From Term

[subs="normal"]
----
from-term ::= from-keyspace ('AS'? alias)? use-clause? | '(' select ')' 'AS'? alias | expr ('AS' alias)? | from-term join-clause | from-term nest-clause | from-term unnest-clause
----

A N1QL expression that defines the input object(s) for the query, which can be either a <<table_vrv_nxx_1db,keyspace identifier>>, xref:n1ql-language-reference/index.adoc[generic expression], or xref:n1ql-language-reference/subqueries.adoc[subquery] along with one or more JOIN, NEST, or UNNEST clause.

=== From Keyspace

[subs="normal"]
----
from-keyspace ::= (namespace ':')? keyspace
namespace ::= identifier
keyspace ::= identifier
----

xref:n1ql-language-reference/identifiers.adoc[Identifier] that represents the keyspace for the query, such as `pass:c[FROM `travel-sample`]`.

=== AS Clause

To assign a name to a keyspace or expression.

=== USE Clause

[subs="normal"]
----
use-clause ::= use-keys-clause | use-index-clause
use-keys-clause ::= 'USE' 'PRIMARY'? 'KEYS' expr
use-index-clause ::= 'USE' 'INDEX' '(' index-ref (',' index-ref)* ')'
index-ref ::= index-name index-using?
----

To specify one or more document keys.

=== SELECT Subquery

To specify a N1QL SELECT subquery

=== JOIN Clause

[subs="normal"]
----
join-clause ::= join-type? 'JOIN' from-keyspace ('AS'? alias)? join-predicate
join-type ::= 'INNER' | 'LEFT' 'OUTER'?
join-predicate ::= lookup-join-predicate | index-join-predicate
lookup-join-predicate ::= 'ON' 'PRIMARY'? 'KEYS' expr
index-join-predicate ::= 'ON' 'PRIMARY'? 'KEY' expr 'FOR' alias
----

Create an input object by combining two or more source objects via <<section_ek1_jnx_1db,ANSI JOIN>>, <<lookup-join-clause,Lookup JOIN>>, or <<index-join-clause,Index JOIN>>.

=== NEST Clause

[subs="normal"]
----
nest-clause ::= join-type? 'NEST' from-keyspace ('AS'? alias)? join-predicate
----

Create an input object by producing a single result of nesting keyspaces via <<section_tc1_nnx_1db,ANSI NEST>>, <<nest,Lookup NEST>>, or <<section_rgr_rnx_1db,Index NEST>>.

=== UNNEST Clause

[subs="normal"]
----
unnest-clause ::= join-type? ('UNNEST' | 'FLATTEN') expr ('AS'? alias)?
----

Create an input object by flattening an array in the parent document.

.Arguments
[cols="10,39"]
|===
| Argument / Clause | Description

a|

::

{empty} . . . <<use-keys-clause,*USE KEYS use-clause*>>
a|


| *expr*
| A N1QL expression generating JSON documents or objects.

a|
|===

[#sec_from-keyspace]
== from-keyspace

You can specify a keyspace to query from, either a specific bucket or a constant expression.
If the [.var]`from-keyspace` clause is used, then there must be a [.var]`from-keyspace-name` specified.

The simplest type of from-keyspace clause specifies a single bucket (i.e., `pass:c[SELECT * FROM `travel-sample`]`).

Keyspace identifier is the name or identifier of an independent place for a data source of one or more documents.
Such keyspaces are not dependent on any of the xref:n1ql-language-reference/subqueries.adoc#section_onz_3tj_mz[Variable in Scope of a Subquery].

=== Examples

.Use a keyspace from a single bucket
====
Select four unique landmarks from the `pass:c[`travel-sample`]` bucket.
[source,N1QL]
----
SELECT DISTINCT name
FROM `travel-sample`
WHERE type = "landmark"
LIMIT 4;
----

.Results
[source,JSON]
----
[
  {
    "name": "Royal Engineers Museum"
  },
  {
    "name": "Hollywood Bowl"
  },
  {
    "name": "Thai Won Mien"
  },
  {
    "name": "Spice Court"
  }
]
----
====

=== N1QL Expressions in a FROM Clause

Couchbase Server version 4.6.2 added support for generic xref:n1ql-language-reference/index.adoc[expressions] in the `from-term` clause; and this adds huge flexibility by the enabling of various N1QL functions, operators, path expressions, language constructs on constant expressions, variables, and subqueries to create just about any FROM clause imaginable.

* When the `from-term` is an expression, `USE KEYS` or `USE INDEX` clauses are not allowed.
* When using a `JOIN` clause, `NEST` clause, or `UNNEST` clause, the left-side keyspace can be an expression or subquery, but the right-side keyspace must be a keyspace identifier.

==== Independent Constant Expression

This includes any N1QL expressions of JSON scalar values, static JSON literals, objects, or N1QL functions, for example:

====
[source,N1QL]
----
SELECT * FROM [1, 2, "name", { "type" : "airport", "id" : "SFO"}]  AS  ks1;
----

[source,N1QL]
----
SELECT CURL("https://maps.googleapis.com/maps/api/geocode/json",
           {"data":"address=Half+Moon+Bay" , "request":"GET"} );
----
====

Note that functions such as xref:n1ql-language-reference/curl.adoc[CURL()] can independently produce input data objects for the query.
Similarly, other N1QL functions can also be used in the expressions.

==== Variable N1QL Expression

This includes expressions that refer to any xref:n1ql-language-reference/subqueries.adoc#section_onz_3tj_mz[variables in scope] for the query, for example:

====
[source,N1QL]
----
SELECT count(*)
FROM `travel-sample` t
LET x = t.geo
WHERE (SELECT RAW y.alt FROM x y)[0] > 6000;
----
====

The `FROM x` clause is an expression that refers to the outer query.
This is applicable to only subqueries because the outermost level query cannot use any variables in its own `FROM` clause.
This makes the subquery correlated with outer queries, as explained in the xref:n1ql-language-reference/subqueries.adoc[Subqueries] section.

==== Subquery and Subquery Expressions

.Subquery Example
====
For each country, find the number of airports at different altitudes and their corresponding cities.

In this case, the inner query finds the first level of grouping of different altitudes by country and corresponding number of cities.
Then the outer query builds on the inner query results to count the number of different altitude groups for each country and the total number of cities.

[source,N1QL]
----
SELECT t1.country, num_alts, total_cities
FROM (SELECT country, geo.alt AS alt,
             count(city) AS num_cities
      FROM `travel-sample`
      WHERE type = "airport"
      GROUP BY country, geo.alt) t1
GROUP BY t1.country
LETTING num_alts = count(t1.alt), total_cities = sum(t1.num_cities);
----

.Results
[source,JSON]
----
[
  {
    "country": "United States",
    "num_alts": 946,
    "total_cities": 1560
  },
  {
    "country": "United Kingdom",
    "num_alts": 128,
    "total_cities": 187
  },
  {
    "country": "France",
    "num_alts": 196,
    "total_cities": 221
  }
]
----
====

This is equivalent to blending the results of the following two queries by country, but the subquery in the `from-term` above simplified it.

====
[source,N1QL]
----
SELECT country,count(city) AS num_cities
FROM `travel-sample`
WHERE type = "airport"
GROUP BY country;
----

[source,N1QL]
----
SELECT country, count(distinct geo.alt) AS num_alts
FROM `travel-sample`
WHERE type = "airport"
GROUP BY country;
----
====

For more details and examples, see xref:n1ql-language-reference/subqueries.adoc[Subqueries] and <<select-expr,( select-expr )>>.

[#section_ax5_2nx_1db]
== AS Alias

To use a shorter or clearer name anywhere in the query, like SQL, N1QL allows renaming fields by using the AS keyword to assign an alias to a keyspace or field in the `FROM` clause.

=== Syntax

----
[AS] alias
----

=== Arguments

`AS`:: [Optional] Reserved word denoting the next word is an alias of the previous term.

alias::
[Required if `AS` is used] String to assign a name to a keyspace, such as the following equivalent `FROM` clauses with and without the `AS` keyword:
+
[cols=2*]
|===
| `pass:c[FROM `travel-sample`]` `AS t`
| `pass:c[FROM `travel-sample`]` `t`

| `pass:c[FROM `travel-sample`]` `AS h`

`pass:c[INNER JOIN `travel-sample`]` `AS l`

`ON (``h``.city =` `l``.city)`
| `pass:c[FROM `travel-sample`]` `h`

`pass:c[INNER JOIN `travel-sample`]` `l`

`ON (``h``.city =` `l``.city)`
|===
+
[NOTE]
====
Since the original name may lead to referencing wrong data and wrong results, you must use the alias name throughout the query instead of the original keyspace name.

In the FROM clause, the renaming appears only in the projection and not the fields themselves.

When no alias is used, the keyspace or last field name of an expression is given as the implicit alias.

When an alias conflicts with a keyspace or field name in the same scope, the identifier always refers to the alias.
This allows for consistent behavior in scenarios where an identifier only conflicts in some documents.
For more information on aliases, see xref:n1ql-language-reference/identifiers.adoc[Identifiers].
====

== USE KEYS Clause

You can refer to a document's unique document key by using the `USE KEYS` clause.
Only documents having those document keys will be included as inputs to a query.

=== Syntax

image::n1ql-language-reference/use-keys-clause.png[]

----
USE [ PRIMARY ] KEYS expr
----

=== Arguments

PRIMARY:: [Optional] `USE KEYS` and `USE PRIMARY KEYS` are synonyms.

expr:: String of a document key or an array of comma-separated document keys.

=== Examples

.Select a single document by its document key
====
[source,N1QL]
----
SELECT *
FROM `travel-sample`
USE KEYS "airport_1254";
----

.Results
[source,JSON]
----
[
  {
    "travel-sample": {
      "airportname": "Calais Dunkerque",
      "city": "Calais",
      "country": "France",
      "faa": "CQF",
      "geo": {
        "alt": 12,
        "lat": 50.962097,
        "lon": 1.954764
      },
      "icao": "LFAC",
      "id": 1254,
      "type": "airport",
      "tz": "Europe/Paris"
    }
  }
]
----
====

.Select multiple documents by their document keys
====
[source,N1QL]
----
SELECT *
FROM `travel-sample`
USE KEYS ["airport_1254","airport_1255"];
----

.Results
[source,JSON]
----
[
  {
    "travel-sample": {
      "airportname": "Calais Dunkerque",
      "city": "Calais",
      "country": "France",
      "faa": "CQF",
      "geo": {
        "alt": 12,
        "lat": 50.962097,
        "lon": 1.954764
      },
      "icao": "LFAC",
      "id": 1254,
      "type": "airport",
      "tz": "Europe/Paris"
    }
  },
  {
    "travel-sample": {
      "airportname": "Peronne St Quentin",
      "city": "Peronne",
      "country": "France",
      "faa": null,
      "geo": {
        "alt": 295,
        "lat": 49.868547,
        "lon": 3.029578
      },
      "icao": "LFAG",
      "id": 1255,
      "type": "airport",
      "tz": "Europe/Paris"
    }
  }
]
----
====

[#select-expr]
== ( select-expr )

Use parenthesis to specify a N1QL `SELECT` expression of input objects.

=== Arguments

select-expr:: [Required] The N1QL `SELECT` query of input objects.

=== Examples

.A `SELECT` clause inside a `FROM` clause.
====
List all `Gillingham` landmark names from a subset of all landmark names and addresses.

[source,N1QL]
----
SELECT name, city
FROM (SELECT id, name, address, city
      FROM `travel-sample`
      WHERE type = "landmark") as Landmark_Info
WHERE city = "Gillingham";
----

.Results
[source,JSON]
----
[
  {
    "city": "Gillingham",
    "name": "Royal Engineers Museum"
  },
  {
    "city": "Gillingham",
    "name": "Hollywood Bowl"
  },
  {
    "city": "Gillingham",
    "name": "Thai Won Mien"
  },
  {
    "city": "Gillingham",
    "name": "Spice Court"
  },
  {
    "city": "Gillingham",
    "name": "Beijing Inn"
  },
  {
    "city": "Gillingham",
    "name": "Ossie's Fish and Chips"
  }
]
----
====

For more details and examples, see xref:n1ql-language-reference/selectclause.adoc[SELECT Clause].

[#section_nkd_3nx_1db]
== from-term

The from-term defines the input object(s) for the query, and it can be one of the following types:

[#table_vrv_nxx_1db,cols="1,3"]
|===
| Type | Example

| <<sec_from-keyspace,keyspace identifier>>
| `pass:c[`travel-sample`]`

| xref:n1ql-language-reference/index.adoc[generic expression]
| `20+10 AS Total`

| xref:n1ql-language-reference/subqueries.adoc[subquery]
a|
[source,N1QL]
----
SELECT t1.country, ARRAY_AGG(t1.city), SUM(t1.city_cnt) AS apnum
FROM (
  SELECT city, city_cnt, ARRAY_AGG(airportname) AS apnames, country
  FROM `travel-sample`
  WHERE type = "airport"
  GROUP BY city, country
  LETTING city_cnt = COUNT(city)
) AS t1
WHERE t1.city_cnt > 5;
----
| previous <<section_ek1_jnx_1db,join>>, <<section_tc1_nnx_1db,nest>>, or <<unnest,unnest>>
a|
[source,N1QL]
----
SELECT *
FROM `travel-sample` AS rte
JOIN `travel-sample` AS aln
  ON rte.airlineid = META(aln).id
NEST `travel-sample` AS lmk
  ON aln.landmarkid = META(lmk).id;
----
|===

For more details with examples, click the above links.

NOTE: Couchbase Server version 4.6.2 adds support for xref:n1ql-language-reference/index.adoc[generic expression] in the from-term.
Prior Couchbase Server versions support only the other two types.

[#UNNEST-Example-1]
.UNNEST an array to select an item
====
In the `travel-sample` keyspace, flatten the schedule array to get a list of the flights on Monday (`1`).

[source,N1QL]
----
SELECT sched
FROM `travel-sample`
UNNEST schedule sched
WHERE  sched.day = 1
LIMIT 3;
----

.Results
[source,JSON]
----
[
  {
    "sched": {
      "day": 1,
      "flight": "AF356",
      "utc": "12:40:00"
    }
  },
  {
    "sched": {
      "day": 1,
      "flight": "AF480",
      "utc": "08:58:00"
    }
  },
  {
    "sched": {
      "day": 1,
      "flight": "AF250",
      "utc": "12:59:00"
    }
  }
]
----

Another way to get similar results is by using a Collection Operator to find array items that meet our criteria:

[source,N1QL]
----
SELECT ARRAY item FOR item IN schedule WHEN item.day = 1 END AS Monday_flights
FROM `travel-sample`
WHERE type = "route"
AND ANY item IN schedule SATISFIES item.day = 1 END
LIMIT 3;
----

However, without the `UNNEST` clause, the unflattened list results in 3 sets of flights instead of only 3 individual flights:

[source,JSON]
----
[
  {
    "Monday_flights": [
      {
        "day": 1,
        "flight": "AF356",
        "utc": "12:40:00"
      },
      {
        "day": 1,
        "flight": "AF480",
        "utc": "08:58:00"
      },
      {
        "day": 1,
        "flight": "AF250",
        "utc": "12:59:00"
      },
      {
        "day": 1,
        "flight": "AF130",
        "utc": "04:45:00"
      }
    ]
  },
  {
    "Monday_flights": [
      {
        "day": 1,
        "flight": "AF517",
        "utc": "13:36:00"
      },
      {
        "day": 1,
        "flight": "AF279",
        "utc": "21:35:00"
      },
      {
        "day": 1,
        "flight": "AF753",
        "utc": "00:54:00"
      },
      {
        "day": 1,
        "flight": "AF079",
        "utc": "15:29:00"
      },
      {
        "day": 1,
        "flight": "AF756",
        "utc": "06:16:00"
      }
    ]
  },
  {
    "Monday_flights": [
      {
        "day": 1,
        "flight": "AF975",
        "utc": "11:23:00"
      },
      {
        "day": 1,
        "flight": "AF225",
        "utc": "16:05:00"
      }
    ]
  }
]
----
====

[#UNNEST-Example-2]
.Use `UNNEST` to collect items from one array to use in another query
====
In this example, the `UNNEST` clause iterates over the `reviews` array and collects the `author` names of the reviewers who rated the rooms less than a 2 to be contacted for ways to improve.
`r` is an element of the array generated by the UNNEST operation.

[source,N1QL]
----
SELECT RAW r.author
FROM `travel-sample`
UNNEST reviews AS r
WHERE `travel-sample`.type = "hotel"
AND r.ratings.Rooms < 2
LIMIT 4;
----

.Results
[source,JSON]
----
[
  "Kayli Cronin",
  "Shanelle Streich",
  "Catharine Funk",
  "Tyson Beatty"
]
----
====
