= Aggregate Functions

Aggregate functions take multiple values from documents, perform calculations, and return a single value as the result.
The function names are case insensitive.

You can only use aggregate functions in `SELECT`, `LETTING`, `HAVING`, and `ORDER BY` clauses.
When using an aggregate function in a query, the query operates as an aggregate query.

Aggregate functions take one argument, which is used to compute the aggregate function.
The `COUNT` function can also take a wildcard ({asterisk}) or a path with a wildcard (path.{asterisk}) as its argument.

If there is no input row for the group, `COUNT` functions return `0`.
All other aggregate functions return NULL.

== ARRAY_AGG([.var]`expression`)

Returns array of the non-MISSING values in the group, including NULL values.

.List all values of the `Cleanliness` reviews given
====
[source,n1ql]
----
SELECT ARRAY_AGG(reviews[0].ratings.Cleanliness) AS Reviews FROM `travel-sample`;
----

.Results
[source,json]
----
[
  {
    "Reviews": [
      -1,
      -1,
      -1,
      -1,
      -1,
...
]}]
----
====

== ARRAY_AGG(DISTINCT [.var]`expression`)

Returns array of the distinct non-MISSING values in the group, including NULL values.

.List all unique values of the `Cleanliness` reviews given
====
[source,n1ql]
----
SELECT ARRAY_AGG(DISTINCT reviews[0].ratings.Cleanliness) AS Reviews FROM `travel-sample`;
----

.Results
[source,json]
----
[
  {
    "UniqueReviews": [
      -1,
      1,
      2,
      3,
      4,
      5
    ]
  }
]
----
====

== AVG([.var]`expression`)

Returns arithmetic mean (average) of all the number values in the group.

.The average altitude of airports in the `travel-sample` keyspace
====
[source,n1ql]
----
SELECT AVG(geo.alt) AS AverageAltitude FROM `travel-sample` WHERE type="airport";
----

.Results
[source,json]
----
[
  {
    "AverageAltitude": 870.1651422764228
  }
]
----
====

== AVG(DISTINCT [.var]`expression`)

Returns arithmetic mean (average) of all the distinct number values in the group.

.The average number of airline route stops vs. the `DISTINCT` average of airline route stops
====
[source,n1ql]
----
SELECT AVG(stops) FROM `travel-sample`; <1>

SELECT AVG(DISTINCT stops) FROM `travel-sample`; <2>
----
====

<1> Results in 0.0002 since nearly all docs have 0 stops.
<2> Results in 0.5 since the docs contain only 1 or 0 stops.

== COUNT(*)

Returns count of all the input rows for the group, regardless of value.

.The number of documents in `travel-sample`
====
[source,n1ql]
----
SELECT COUNT(*) AS CountAll FROM `travel-sample`;
----

.Results
[source,json]
----
[
  {
    "CountAll": 31591
  }
]
----
====

== COUNT([.var]`expression`)

Returns count of all the non-NULL and non-MISSING values in the group.

.The number of documents with an airline route stop in `travel-sample` regardless of its value
====
[source,n1ql]
----
SELECT COUNT(stops) AS CountOfStops FROM `travel-sample`;
----

.Results
[source,json]
----
[
  {
    "CountOfStops": 24024
  }
]
----
====

== COUNT(DISTINCT [.var]`expression`)

Returns count of all the distinct non-NULL and non-MISSING values in the group.

.The number of unique values of airline route stops in `travel-sample`
====
[source,n1ql]
----
SELECT COUNT(DISTINCT stops) AS CountOfDistinctStops FROM `travel-sample`;
----

.Results
[source,json]
----
[
  {
    "CountOfSDistinctStops": 2 <1>
  }
]
----
====

<1> Results in 2 because there are only 0 or 1 stops.

== MAX([.var]`expression`)

Returns the maximum non-NULL, non-MISSING value in the group in N1QL collation order.

.Max of an integer field
====
Find the northernmost latitude of any hotel in `travel-sample`.

[source,n1ql]
----
SELECT MAX(geo.lat) AS MaxLatitude FROM `travel-sample` WHERE type="hotel";
----

.Results
[source,json]
----
[
  {
    "MaxLatitude": 60.15356
  }
]
----
====

.Max of a string field
====
Find the hotel whose name is last alphabetically in `travel-sample`.

[source,n1ql]
----
SELECT MAX(name) AS MaxName FROM `travel-sample` WHERE type="hotel";
----

.Results
[source,json]
----
[
  {
    "MaxName": "pentahotel Birmingham"
  }
]
----
====

That result might have been surprising since lowercase letters come after uppercase letters and are therefore "higher" than uppercase letters.
To avoid this uppercase/lowercase confusion, you should first make all values uppercase or lowercase, as in the following example.

.Max of a string field, regardless of case
====
Find the hotel whose name is last alphabetically in `travel-sample`.

[source,n1ql]
----
SELECT MAX(UPPER(name)) AS MaxName FROM `travel-sample` WHERE type="hotel";
----

.Results
[source,json]
----
[
  {
    "MaxName": "YOSEMITE LODGE AT THE FALLS"
  }
]
----
====

[[median,MEDIAN()]]
== MEDIAN([.var]`expression`)

Returns the median of all the number values in the group.

.The median altitude of airports in the `travel-sample` keyspace
====
[source,n1ql]
----
SELECT MEDIAN(geo.alt) AS MedianAltitude FROM `travel-sample` WHERE type="airport";
----

.Results
[source,json]
----
[
  {
    "MedianAltitude": 361.5
  }
]
----
====

[[median_distinct,MEDIAN(DISTINCT)]]
== MEDIAN(DISTINCT [.var]`expression`)

Returns the median of all the distinct number values in the group.

.The median of distinct altitudes of airports in the `travel-sample` keyspace
====
[source,n1ql]
----
SELECT MEDIAN(DISTINCT geo.alt) AS MedianDistinctAltitude FROM `travel-sample` WHERE type="airport";
----

.Results
[source,json]
----
[
  {
    "MedianDistinctAltitude": 758
  }
]
----
====

== MIN([.var]`expression`)

Returns the minimum non-NULL, non-MISSING value in the group in N1QL collation order.

.Min of an integer field
====
Find the southernmost latitude of any hotel in `travel-sample`.

[source,n1ql]
----
SELECT MIN(geo.lat) AS MinLatitude FROM `travel-sample` WHERE type="hotel";
----

.Results
[source,json]
----
[
  {
    "MinLatitude": 32.68092
  }
]
----
====

.Min of a string field
====
Find the hotel whose name is first alphabetically in `travel-sample`.

[source,n1ql]
----
SELECT MIN(name) AS MinName FROM `travel-sample` WHERE type="hotel";
----

.Results
[source,json]
----
[
  {
    "MinName": "'La Mirande Hotel"
  }
]
----
====

That result might have been surprising since some symbols come before letters and are therefore "lower" than letters.
To avoid this symbol confusion, you can specify letters only, as in the following example.

.Min of a string field, regardless of preceding non-letters.
====
Find the first hotel alphabetically in `travel-sample`

[source,n1ql]
----
SELECT MIN(name) AS MinName FROM `travel-sample` WHERE type="hotel" AND SUBSTR(name,0)>="A";
----

.Results
[source,json]
----
[
  {
    "MinName": "AIRE NATURELLE LE GROZEAU Aire naturelle"
  }
]
----
====

[[stddev,STDDEV()]]
== STDDEV([.var]`expression`)

Returns the <<eqn_samp_std_dev,corrected sample standard deviation>> of all the number values in the group.

This function has a near-synonym <<stddev_samp>>.
The only difference is that `STDDEV()` returns NULL if there is only one matching element.

.Sample standard deviation of all values
====
[source,n1ql]
----
SELECT STDDEV(reviews[0].ratings.Cleanliness) AS StdDev FROM `travel-sample` WHERE city="London" AND `type`="hotel";
----

.Results
[source,json]
----
[
  {
    "StdDev": 2.0554275433769753
  }
]
----
====

.Sample standard deviation of a single value
====
[source,n1ql]
----
SELECT STDDEV(reviews[0].ratings.Cleanliness) AS StdDevSingle FROM `travel-sample` WHERE name="Sachas Hotel";
----

.Results
[source,json]
----
[
  {
    "StdDevSingle": 0 <1>
  }
]
----
====

<1> There is only one matching result in the input, so the function returns `0`.

[[stddev_distinct,STDDEV(DISTINCT)]]
== STDDEV(DISTINCT [.var]`expression`)

Returns the <<eqn_samp_std_dev,corrected sample standard deviation>> of all the distinct number values in the group.

This function has a near-synonym <<stddev_samp_distinct>>.
The only difference is that `STDDEV(DISTINCT)` returns NULL if there is only one matching element.

.Sample standard deviation of distinct values
====
[source,n1ql]
----
SELECT STDDEV(DISTINCT reviews[0].ratings.Cleanliness) AS StdDevDistinct FROM `travel-sample` WHERE city="London" AND `type`="hotel";
----

.Results
[source,json]
----
[
  {
    "StdDevDistinct": 2.1602468994692865
  }
]
----
====

[[stddev_pop,STDDEV_POP()]]
== STDDEV_POP([.var]`expression`)

Returns the <<eqn_pop_std_dev,population standard deviation>> of all the number values in the group.

.Population standard deviation of all values
====
[source,n1ql]
----
SELECT STDDEV_POP(reviews[0].ratings.Cleanliness) AS PopStdDev FROM `travel-sample` WHERE city="London" AND `type`="hotel";
----

.Results
[source,json]
----
[
  {
    "PopStdDev": 2.0390493736539432
  }
]
----
====

[[stddev_pop_distinct,STDDEV_POP(DISTINCT)]]
== STDDEV_POP(DISTINCT [.var]`expression`)

Returns the <<eqn_pop_std_dev,population standard deviation>> of all the distinct number values in the group.

.Population standard deviation of distinct values
====
[source,n1ql]
----
SELECT STDDEV_POP(DISTINCT reviews[0].ratings.Cleanliness) AS PopStdDevDistinct FROM `travel-sample` WHERE city="London" AND `type`="hotel";
----

.Results
[source,json]
----
[
  {
      "PopStdDevDistinct": 1.9720265943665387
  }
]
----
====

[[stddev_samp,STDDEV_SAMP()]]
== STDDEV_SAMP([.var]`expression`)

A near-synonym for <<stddev>>.
The only difference is that `STDDEV_SAMP()` returns NULL if there is only one matching element.

.Sample standard deviation of a single value
====
[source,n1ql]
----
SELECT STDDEV_SAMP(reviews[0].ratings.Cleanliness) AS StdDevSamp FROM `travel-sample` WHERE name="Sachas Hotel";
----

.Results
[source,json]
----
[
  {
    "StdDevSamp": null <1>
  }
]
----
====

<1> There is only one matching result in the input, so the function returns NULL.

[[stddev_samp_distinct,STDDEV_SAMP(DISTINCT)]]
== STDDEV_SAMP(DISTINCT [.var]`expression`)

A near-synonym for <<stddev_distinct>>.
The only difference is that `STDDEV_SAMP(DISTINCT)` returns NULL if there is only one matching element.

== SUM([.var]`expression`)

Returns sum of all the number values in the group.

.The sum total of all airline route stops in `travel-sample`
====
NOTE: In the travel-sample bucket, nearly all flights are non-stop (0 stops) and only six flights have 1 stop, so we expect 6 flights of 1 stop each, a total of 6.

[source,n1ql]
----
SELECT SUM(stops) AS SumOfStops FROM `travel-sample`;
----

.Results
[source,json]
----
[
  {
    "SumOfStops": 6 <1>
  }
]
----
====

<1> There are 6 routes with 1 stop each.

== SUM(DISTINCT [.var]`expression`)

Returns arithmetic sum of all the distinct number values in the group.

.The sum total of all unique numbers of airline route stops in `travel-sample`
====
[source,n1ql]
----
SELECT SUM(DISTINCT stops) AS SumOfDistinctStops FROM `travel-sample`;
----

.Results
[source,json]
----
[
  {
    "SumOfDistinctStops": 1 <1>
  }
]
----
====

<1> There are only 0 and 1 stops per route; and 0 + 1 = 1.

[[variance,VARIANCE()]]
== VARIANCE([.var]`expression`)

Returns the unbiased sample variance (the square of the <<eqn_samp_std_dev,corrected sample standard deviation>>) of all the number values in the group.

This function has a near-synonym <<var_samp>>.
The only difference is that `VARIANCE()` returns NULL if there is only one matching element.

.Sample variance of all values
====
[source,n1ql]
----
SELECT VARIANCE(reviews[0].ratings.Cleanliness) AS Variance FROM `travel-sample` WHERE city="London" AND `type`="hotel";
----

.Results
[source,json]
----
[
  {
    "Variance": 4.224782386072708
  }
]
----
====

.Sample variance of a single value
====
[source,n1ql]
----
SELECT VARIANCE(reviews[0].ratings.Cleanliness) AS VarianceSingle FROM `travel-sample` WHERE name="Sachas Hotel";
----

.Results
[source,json]
----
[
  {
    "VarianceSingle": 0 <1>
  }
]
----
====

<1> There is only one matching result in the input, so the function returns `0`.

[[variance_distinct,VARIANCE(DISTINCT)]]
== VARIANCE(DISTINCT [.var]`expression`)

Returns the unbiased sample variance (the square of the <<eqn_samp_std_dev,corrected sample standard deviation>>) of all the distinct number values in the group.

This function has a near-synonym <<variance_samp_distinct>>.
The only difference is that `VARIANCE(DISTINCT)` returns NULL if there is only one matching element.

.Sampling variance of distinct values
====
[source,n1ql]
----
SELECT VARIANCE(DISTINCT reviews[0].ratings.Cleanliness) AS VarianceDistinct FROM `travel-sample` WHERE city="London" AND `type`="hotel";
----

.Results
[source,json]
----
[
  {
    "VarianceDistinct": 4.666666666666667
  }
]
----
====

[[variance_pop,VARIANCE_POP()]]
== VARIANCE_POP([.var]`expression`)

Returns the population variance (the square of the <<eqn_pop_std_dev,population standard deviation>>) of all the number values in the group.

This function has an alias <<var_pop>>.

.Population variance of all values
====
[source,n1ql]
----
SELECT VARIANCE_POP(reviews[0].ratings.Cleanliness) AS PopVariance FROM `travel-sample` WHERE city="London" AND `type`="hotel";
----

.Results
[source,json]
----
[
  {
    "PopVariance": 4.157722348198537
  }
]
----
====

[[variance_pop_distinct,VARIANCE_POP(DISTINCT)]]
== VARIANCE_POP(DISTINCT [.var]`expression`)

Returns the population variance (the square of the <<eqn_pop_std_dev,population standard deviation>>) of all the distinct number values in the group.

This function has an alias <<var_pop_distinct>>.

.Population variance of distinct values
====
[source,n1ql]
----
SELECT VARIANCE_POP(DISTINCT reviews[0].ratings.Cleanliness) AS PopVarianceDistinct FROM `travel-sample` WHERE city="London" AND `type`="hotel";
----

.Results
[source,json]
----
[
  {
      "PopVarianceDistinct": 3.8888888888888893
  }
]
----
====

[[variance_samp,VARIANCE_SAMP()]]
== VARIANCE_SAMP([.var]`expression`)

A near-synonym for <<variance>>.
The only difference is that `VARIANCE_SAMP()` returns NULL if there is only one matching element.

This function has an alias <<var_samp>>.

.Sample standard deviation of a single value
====
[source,n1ql]
----
SELECT VARIANCE_SAMP(reviews[0].ratings.Cleanliness) AS VarianceSamp FROM `travel-sample` WHERE name="Sachas Hotel";
----

.Results
[source,json]
----
[
  {
    "VarianceSamp": null <1>
  }
]
----
====

<1> There is only one matching result in the input, so the function returns NULL.

[[variance_samp_distinct,VARIANCE_SAMP(DISTINCT)]]
== VARIANCE_SAMP(DISTINCT [.var]`expression`)

A near-synonym for <<variance_distinct>>.
The only difference is that `VARIANCE_SAMP(DISTINCT)` returns NULL if there is only one matching element.

This function has an alias <<var_samp_distinct>>.

[[var_pop,VAR_POP()]]
== VAR_POP([.var]`expression`)

Alias for <<variance_pop>>.

[[var_pop_distinct,VAR_POP(DISTINCT)]]
== VAR_POP(DISTINCT [.var]`expression`)

Alias for <<variance_pop_distinct>>.

[[var_samp,VAR_SAMP()]]
== VAR_SAMP([.var]`expression`)

Alias for <<variance_samp>>.

[[var_samp_distinct,VAR_SAMP(DISTINCT)]]
== VAR_SAMP(DISTINCT [.var]`expression`)

Alias for <<variance_samp_distinct>>.

== Related Links

xref:n1ql-language-reference/groupby.adoc[GROUP BY Clause] for GROUP BY, LETTING, and HAVING clauses.
