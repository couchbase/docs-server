= Array Indexing
:description: Array Indexing adds the capability to create global indexes on array elements and optimizes the execution of queries involving array elements.
:imagesdir: ../../assets/images

:expression: xref:n1ql-language-reference/index.adoc
:createindex: xref:n1ql-language-reference/createindex.adoc
:install-sample-buckets: xref:manage:manage-settings/install-sample-buckets.adoc
:covering-indexes: xref:indexes:covering-indexes.adoc
:use-index-clause: xref:n1ql-language-reference/hints.adoc#use-index-clause

{description}

This is a huge leap from the previous versions where secondary indexes could only be created and subsequently queried on whole arrays.
You can now create an index of array elements ranging from plain scalar values to complex arrays or JSON objects nested deeper in the array.

== Syntax

To create an array index, the overall syntax is the same as for a global secondary index.
The distinguishing feature is the use of an array expression as an index key.

Refer to the {createindex}[CREATE INDEX] statement for details of the syntax.

[[index-key,index-key]]
=== Index Key

[source,ebnf]
----
include::partial$grammar/ddl.ebnf[tag=index-key]
----

image::n1ql-language-reference/index-key.png[align=left]

Refers to an attribute name or a scalar function or an ARRAY expression on the attribute.
This constitutes an index-key for the index.

[[index-key-args]]
expr::
A {expression}[N1QL expression] over any fields in the document.
This cannot use constant expressions, aggregate functions, or sub-queries.

array-expr::
Refer to <<array-expr>> below.

[[array-expr]]
=== Array Expression

[source,ebnf]
----
include::partial$grammar/ddl.ebnf[tag=array-expr]
----

image::n1ql-language-reference/array-expr.png[align=left]

The array expression can be either a <<full-array-expr>>, which includes an `ARRAY` operator, or a <<simple-array-expr>>, which does not.

[IMPORTANT]
====
The query predicate which appears in the WHERE clause of a SELECT, UPDATE, or DELETE statement must have exactly the same format as the variable in the array index key.
See <<query-predicate-format>> for details.
====

[NOTE]
====
Currently, array indexing is limited to using only one index-key with the array expression.

* To create an array index involving multiple array elements or multiple arrays, use a full array expression whose <<full-array-expr-args,variable expression>> is constructed as a compound object constituted with different elements of the same array or multiple arrays.

* Subsequent SELECT or DML statements must use similar compound objects in the WHERE clause to use the array index.
See <<examples>> below.

* For an UNNEST scan to use an index, the leading key of the index definition must be an appropriate ARRAY index key.
In Couchbase Server 6.0.1 and later, the UNNEST scan can generate index spans on other non-leading index keys when appropriate predicates exist.
====

[[full-array-expr,full array expression]]
==== Full Array Expression

[source,ebnf]
----
include::partial$grammar/ddl.ebnf[tag=full-array-expr]
----

image::n1ql-language-reference/full-array-expr.png[align=left]

The [.cmd]`ARRAY` operator lets you map and filter the elements or attributes of a collection, object, or objects.
It evaluates to an array of the operand expression that satisfies the WHEN clause, if specified.

[[full-array-expr-args]]
var-expr::
A function of the [.var]`var` variable used in the FOR clause.

var::
Represents elements in the array specified by [.var]`expr`.

expr::
Evaluates to an array of objects, elements of which are represented by the [.var]`var` variable.

cond::
Specifies predicates to qualify the subset of documents to include in the index array.

NOTE: The [.var]`var-expr` itself can be a nested <<array-expr,array expression>>.
This enables creating array indexes on nested array fields.
See <<examples>> below.

[[simple-array-expr,simple array expression]]
==== Simple Array Expression

[source,ebnf]
----
include::partial$grammar/ddl.ebnf[tag=simple-array-expr]
----

image::n1ql-language-reference/simple-array-expr.png[align=left]

Couchbase Server 5.0 and later provides a simpler syntax for array indexing when all array elements are indexed as is, without needing to use the `ARRAY` operator in the index definition.

[[simple-array-expr-args]]
expr::
An array field name, or an expression that can evaluate to an array.
In this case, all elements of the array are indexed.

[#query-predicate-format]
== Format of Query Predicate

The query predicate which appears in the WHERE clause of a SELECT, UPDATE, or DELETE statement must have exactly the same format as the variable in the array index key.

A SELECT query or DML statement that needs to use the array index can use different variable names in the query from those used in the array index definition.

Consider the following expressions used in a CREATE INDEX statement:

[source,n1ql]
----
DISTINCT ARRAY f(x) FOR x IN expr1 END; -- <1>
DISTINCT ARRAY f(x) FOR x WITHIN expr1 END; -- <2>
----

And the following expressions used in the SELECT statement WHERE clause:

[source,n1ql]
----
ANY x IN expr2 SATISFIES g(x) END; -- <3>
ANY x WITHIN expr2 SATISFIES g(x) END -- <4>
----

The following dependencies must be satisfied for the Query service to consider the array index:

* The index keys used in CREATE INDEX must be used in the WHERE clause.

* [.var]`expr2` in ➂ and ➃ must be equivalent to [.var]`expr1` in ➀ and ➁.
This is a formal notion of equivalence.
For example, if they are the same expressions, or equivalent arithmetic expressions such as `(x+y)` and `(y+x)`.

* If there is a need to index one or more expressions from the ARRAY (the maximum being 32), the [.var]`fx()` expression can be specified as `FLATTEN_KEYS(f1(x) [ASC|DESC], f2(x) [ASC|DESC], . . . )`.
When `FLATTEN_KEYS()` is present, it flattens arguments within the array, as if they were separate index keys; and all subsequent index keys are accordingly moved to the right.
Queries will be sargable and will generate spans.

* [.var]`g(x)` in ➂ and ➃ must be sargable for [.var]`f(x)` in ➀ and ➁.
In other words, if there were a scalar index with key [.var]`f(x)`, then that index would be applicable to the predicate [.var]`g(x)`.
For example, the index key `UPPER(x)` is sargable for the predicate `UPPER(x) LIKE "John%"`.
[.var]`g(x)` in ➂ and ➃ must be sargable for `f(x)`; or, if f(x) is `FLATTEN_KEYS()`, for one of its arguments in ➀ and ➁.

* IN vs. WITHIN: Index key ➀ can be used for query predicate ➂.
Index key ➁ can be used for both query predicates ➂ and ➃.

NOTE: Index key ➁ is strictly more expensive than index key ➀, for both index maintenance and query processing.
Index key ➁ and query predicate ➃ are very powerful.
They can efficiently index and query recursive trees of arbitrary depth.

[#examples]
== Examples

The following examples use the {install-sample-buckets}[travel-sample] bucket that is shipped with Couchbase Server.

[[example-1]]
.Indexing all DISTINCT elements in an array
====
.Index: Create an index on all schedules
[[C1,Index]]
[source,N1QL]
----
CREATE INDEX idx_sched
ON `travel-sample`.inventory.route
( DISTINCT ARRAY v.flight FOR v IN schedule END );
----

.Query: Find the list of scheduled 'UA' flights
[[Q1,Query]]
[source,N1QL]
----
SELECT * FROM `travel-sample`.inventory.route
WHERE ANY v IN schedule SATISFIES v.flight LIKE 'UA%' END;
----
====

[[example-2]]
.Partial index (with WHERE clause) of individual attributes from selected elements (using WHEN clause) of an array
====
.Index: Create an index on flights from San Francisco scheduled in the first 4 days of the week
[[C2,Index]]
[source,N1QL]
----
CREATE INDEX idx_flight_sfo
ON `travel-sample`.inventory.route
( ALL ARRAY v.flight FOR v IN schedule WHEN v.day < 4 END )
WHERE sourceairport = "SFO";
----

.Query: Find the list of scheduled 'UA' flights on day 1
[[Q2,Query]]
[source,N1QL]
----
SELECT * FROM `travel-sample`.inventory.route
WHERE sourceairport = "SFO" -- <1>
AND ANY v IN schedule SATISFIES (v.flight LIKE 'UA%') -- <2>
AND (v.day=1) END; -- <3>
----

In this example, the <<C2>> qualifies for the <<Q2>> because:

<1> The <<Q2>> predicate `sourceairport = "SFO"` matches that of the partial index WHERE clause.
<2> The ANY operator uses the index key `v.flight` on which the <<C2>> is defined.
<3> The ANY-SATISFIES condition `v.day=1` in the <<Q2>> is sargable to that in the index definition WHEN clause `v.day < 4`.
====


[[example-3]]
.Indexing composite elements from the array
====
.Index: Create an index on day and flight from schedule array
[[C3,Index]]
[source,N1QL]
----
CREATE INDEX ixf_sched
  ON `travel-sample`.inventory.route (ALL ARRAY FLATTEN_KEYS(s.day DESC, s.flight)
  FOR s IN schedule
  END,
  sourceairport, destinationairport, stops);
----

.Query A: Find the weekday Delta flights FROM SFO to ATL
[[Q3A,Query A]]
[source,N1QL]
----
SELECT META(r).id
  FROM `travel-sample`.inventory.route AS r
  WHERE r.sourceairport = "SFO" -- <1>
    AND r.destinationairport = "ATL" -- <2>
    AND ANY s IN r.schedule SATISFIES s.day BETWEEN 1 AND 5 -- <3>
    AND s.flight LIKE "DL%" END; -- <4>
----

.Partial Explain Plan
[source,JSON]
----
"spans": [
             {
                 "exact": true,
                 "range": [
                     {
                         "high": "5",
                         "inclusion": 3,
                         "index_key": "(`s`.`day`)", // <3>
                         "low": "1"
                     },
                     {
                         "high": "\"DM\"",
                         "inclusion": 1,
                         "index_key": "(`s`.`flight`)", // <4>
                         "low": "\"DL\""
                     },
                     {
                         "high": "\"SFO\"",
                         "inclusion": 3,
                         "index_key": "`sourceairport`", // <1>
                         "low": "\"SFO\""
                     },
                     {
                         "high": "\"ATL\"",
                         "inclusion": 3,
                         "index_key": "`destinationairport`", // <2>
                         "low": "\"ATL\""
                     }

                 ]
             }
         ]
----

In this example, <<Q3A>> is able to use the `ixf_sched` index defined by the <<C3>>, pass all the predicate information to index scan, and cover the query.

<1> `r.sourceairport = "SFO"` is able to match and pass to IndexScan.
<2> `r.destinationairport = "ATL"` is able to match and pass to IndexScan.
<3> ARRAY predicate `s.day BETWEEN 1 AND 5` is able to match and pass to IndexScan.
<4> ARRAY predicate `s.flight LIKE "DL%"` is able to match and pass to IndexScan.

.Query B: Find the weekday Delta flights from SFO to ATL
[[Q3B,Query B]]
[source,N1QL]
----
SELECT  s.day, s.flight,r.sourceairport, r.destinationairport, r.stops
FROM `travel-sample`.inventory.route AS r
UNNEST r.schedule AS s
WHERE r.sourceairport = "SFO" AND r.destinationairport = "ATL"
      AND s.day BETWEEN 1 AND 5 AND s.flight LIKE "DL%"
ORDER BY s.day DESC
OFFSET 2
LIMIT 3;
----

This query performs a covering UNNEST IndexScan, by applying all the predicates, using the `ixf_sched` index defined by the <<C3>>.
Even though the ORDER BY key uses an array index key, it can use index order, and pass LIMIT and OFFSET to the indexer.
====

[[example-4]]
.Compound array index with individual elements of an array and other non-array fields
====
.Index: Create an index on scheduled flight IDs and number of stops
[[C4,Index]]
[source,N1QL]
----
CREATE INDEX idx_flight_stops
ON `travel-sample`.inventory.route
    ( stops, DISTINCT ARRAY v.flight FOR v IN schedule END );
----

.Query: Find the list of scheduled 'FL' flights that have one or more stops
[[Q4,Query]]
[source,N1QL]
----
SELECT * FROM `travel-sample`.inventory.route
WHERE stops >=1
AND ANY v IN schedule SATISFIES v.flight LIKE 'FL%' END;
----
====

[[example-5]]
.Indexing the individual elements of nest arrays
====
Use the DISTINCT ARRAY clause in a nested fashion to index specific attributes of a document when the array contains other arrays or documents that contain arrays.
For example,

.Update: Create a nested array [.var]`special_flights`
[source,N1QL]
----
UPDATE `travel-sample`.inventory.route
SET schedule[0] = {"day" : 7, "special_flights" :
               [ {"flight" : "AI444", "utc" : "4:44:44"},
                 {"flight" : "AI333", "utc" : "3:33:33"}
               ] }
WHERE destinationairport = "CDG" AND sourceairport = "TLV";
----

.Index I: Create a partial index on a nested array [.var]`special_flights`
[[C5i,Index I]]
[source,N1QL]
----
CREATE INDEX idx_nested ON `travel-sample`.inventory.route
    (DISTINCT ARRAY
        (DISTINCT ARRAY y.flight -- <1>
        FOR y IN x.special_flights END)
    FOR x IN schedule END);
----

<1> In this case, the inner ARRAY construct is used as the [.var]`var_expr` for the outer ARRAY construct in the N1QL Syntax above.

.Query A: Use nested ANY operator to use the index
[[Q5A,Query A]]
[source,N1QL]
----
SELECT count(*) FROM `travel-sample`.inventory.route
WHERE ANY x in schedule SATISFIES
    (ANY y in x.special_flights SATISFIES y.flight IS NOT NULL END)
END;
----

This query uses the index `idx_nested` defined by <<C5i>>.
It returns 3 results, as there are 3 routes with special flights.

.Query B: Use UNNEST operators to use the index
[[Q5B,Query B]]
[source,N1QL]
----
SELECT count(*) FROM `travel-sample`.inventory.route
UNNEST schedule AS x
UNNEST x.special_flights AS y
WHERE y.flight IS NOT NULL;
----

This query uses the index `idx_nested` defined by <<C5i>>.
It returns 6 results, as there are 3 routes with 2 special flights each.

.Index II: Create a partial index on a nested array [.var]`special_flights`
[[C5ii,Index II]]
[source,N1QL]
----
CREATE INDEX ixf_sched_nested ON `travel-sample`.inventory.route
    (ALL ARRAY
        (ALL ARRAY FLATTEN_KEYS(s.day, sf.flight)
         FOR sf IN s.special_flights END)
    FOR s IN schedule END);
----

.Query C: Use nested ANY operator to use the index
[[Q5C,Query C]]
[source,N1QL]
----
SELECT RAW count(1)
FROM `travel-sample`.inventory.route AS r
WHERE ANY s IN schedule
      SATISFIES (ANY sf IN s.special_flights
                 SATISFIES sf.flight IS NOT NULL AND s.day = 7
                 END)
      END;
----

This query performs a covering UNNEST IndexScan, by applying the predicates on both levels of the ARRAY, using the index `ixf_sched_nested` defined by <<C5ii>>.

.Query D: Use UNNEST operators to use the index
[[Q5D,Query D]]
[source,N1QL]
----
SELECT RAW count(1)
FROM `travel-sample`.inventory.route AS r
UNNEST r.schedule AS s
UNNEST s.special_flights AS sf
WHERE sf.flight IS NOT NULL AND s.day = 7;
----

This query performs a covering UNNEST IndexScan, by applying the predicates on both levels of the ARRAY, using the index `ixf_sched_nested` defined by <<C5ii>>; and uses index aggregation.
====

[[example-6]]
.Array Index with multiple elements of an array
====
.Index: Create an index on [.var]`flight` and [.var]`day` fields in [.var]`schedule`
[[C6,Index]]
[source,N1QL]
----
CREATE INDEX idx_flight_day ON `travel-sample`.inventory.route
    (DISTINCT ARRAY [v.flight, v.day] FOR v IN schedule END);
----

.Query: Find the list of scheduled 'US681' flights on day 2
[[Q6,Query]]
[source,N1QL]
----
SELECT meta().id FROM `travel-sample`.inventory.route
WHERE ANY v in schedule SATISFIES [v.flight, v.day] = ["US681", 2] END;
----
====

[[example-7]]
.Indexing all elements in an array using simplified syntax
====
.Index: Create an index on all schedules using simplified array index syntax
[[C7,Index]]
[source,N1QL]
----
CREATE INDEX idx_sched_simple
ON `travel-sample`.inventory.route (ALL schedule);
----

.Query A: Find details of all route documents matching a specific schedule
[[Q7A,Query A]]
[source,N1QL]
----
SELECT * FROM `travel-sample`.inventory.route
WHERE ANY v IN schedule
SATISFIES v = {"day":2, "flight": "US681", "utc": "19:20:00"} END; -- <1>
----

<1> Elements of the schedule array are objects, and hence the right side value of the predicate condition should be a similarly structured object.

.Query B: Find details of all route documents matching a specific schedule
[[Q7B,Query B]]
[source,N1QL]
----
SELECT * FROM `travel-sample`.inventory.route t
UNNEST schedule sch
WHERE sch = {"day":2, "flight": "US681", "utc": "19:20:00"};
----

This is a variant of <<Q7A>> using UNNEST in the SELECT statement.

.Query C: Alternative using an index with FLATTEN_KEYS
[[Q7C,Query C]]
[source,N1QL]
----
SELECT META(r).id
FROM `travel-sample`.inventory.route AS r
WHERE ANY v IN r.schedule SATISFIES v.day = 2 AND v.flight = "US681" END;
----

This query performs a covering IndexScan, by applying all the predicates, using `ixf_sched` defined by the <<C3>> in <<example-3>>.
The query-syntax is intuitive, since the multiple fields within the array have not required complex indexing.
====

== Covering Array Index

Covering indexes are an efficient method of using an Index for a particular query, whereby the index itself can completely cover the query in terms of providing all data required for the query.
Basically, it avoids the fetch phase of the query processing and related overhead in fetching the required documents from data-service nodes.
For more details, see {covering-indexes}[Covering Indexes].

Array indexing requires special attention to create covering array indexes.
In general, the array field itself should be included as one of the index keys in the CREATE INDEX definition.
For instance, in <<example-1>>, the <<C1>> does not cover the <<Q1>> because the <<Q1>> projection list includes * which needs to fetch the document from the Data Service.

[[example-8]]
.Covering Array Index
====
.Index I: Creating a Covering Array Index
[[C8i,Index I]]
[source,N1QL]
----
CREATE INDEX idx_sched_cover ON `travel-sample`.inventory.route
    (DISTINCT ARRAY v.flight FOR v IN schedule END, schedule);
----

The index keys of an index must be used in the WHERE clause of a DML statement to use the index for that query.
In the SELECT or DML WHERE clause, Covering Array Indexes can be used by the following operators:

* ANY: As shown in <<Q8A>> below.
* ANY AND EVERY: As shown in <<Q8B>> (a variant of <<Q8A>>) below.

.Query A: Covering Array Index using the ANY clause
[[Q8A,Query A]]
[source,N1QL]
----
EXPLAIN SELECT meta().id FROM `travel-sample`.inventory.route
USE INDEX (idx_sched_cover) -- <1>
WHERE ANY v IN schedule SATISFIES v.flight LIKE 'UA%' END;
----

<1> In this example, <<Q8A>> needs <<C8i>> to cover it because the query predicate refers to the array `schedule` in the ANY operator.

[source,JSON]
.Result
----
[
  {
    "plan": {
      "#operator": "Sequence",
      "~children": [
        {
          "#operator": "DistinctScan",
          "scan": {
            "#operator": "IndexScan3",
            "bucket": "travel-sample",
            "covers": [
              "cover ((distinct (array (`v`.`flight`) for `v` in (`route`.`schedule`) end)))",
              "cover ((`route`.`schedule`))",
              "cover ((meta(`route`).`id`))"
            ],
            "filter": "cover (any `v` in (`route`.`schedule`) satisfies ((`v`.`flight`) like \"UA%\") end)",
            "filter_covers": {
              "cover (any `v` in (`route`.`schedule`) satisfies ((\"UA\" <= (`v`.`flight`)) and ((`v`.`flight`) < \"UB\")) end)": true,
              "cover (any `v` in (`route`.`schedule`) satisfies ((`v`.`flight`) like \"UA%\") end)": true
            },
            "index": "idx_sched_cover",
          // ...
          }
        }
      ]
    }
  }
]
----

.Query B: Covering Array Index using the ANY AND EVERY clause
[[Q8B,Query B]]
[source,N1QL]
----
EXPLAIN SELECT meta().id FROM `travel-sample`.inventory.route
USE INDEX (idx_sched_cover)
WHERE ANY AND EVERY v IN schedule SATISFIES v.flight LIKE 'UA%' END;
----

[source,JSON]
.Result
----
[
  {
    "plan": {
      "#operator": "Sequence",
      "~children": [
        {
          "#operator": "DistinctScan",
          "scan": {
            "#operator": "IndexScan3",
            "bucket": "travel-sample",
            "covers": [
              "cover ((distinct (array (`v`.`flight`) for `v` in (`route`.`schedule`) end)))",
              "cover ((`route`.`schedule`))",
              "cover ((meta(`route`).`id`))"
            ],
            "filter": "any and every `v` in cover ((`route`.`schedule`)) satisfies ((`v`.`flight`) like \"UA%\") end",
            "index": "idx_sched_cover",
          // ...
          }
        }
      ]
    }
  }
]
----

.Query C: Covering Array Index using the UNNEST clause and aliasing
[[Q8C,Query C]]
[source,N1QL]
----
EXPLAIN SELECT meta(t).id FROM `travel-sample`.inventory.route t
USE INDEX (idx_sched_cover)
UNNEST schedule v
WHERE v.flight LIKE 'UA%';
----

[source,JSON]
.Result
----
[
  {
    "plan": {
      "#operator": "Sequence",
      "~children": [
        {
          "#operator": "DistinctScan",
          "scan": {
            "#operator": "IndexScan3",
            "as": "t",
            "bucket": "travel-sample",
            "covers": [
              "cover ((distinct (array (`v`.`flight`) for `v` in (`t`.`schedule`) end)))",
              "cover ((`t`.`schedule`))",
              "cover ((meta(`t`).`id`))"
            ],
            "filter": "is_array(cover ((`t`.`schedule`)))",
            "index": "idx_sched_cover",
          // ...
          }
        }
      ]
    }
  }
]
----

[NOTE]
--
In this example, <<Q8A>> has the following limitation: the collection operator EVERY cannot use array indexes or covering array indexes because the EVERY operator needs to apply the SATISFIES predicate to all elements in the array, including the case where an array has zero elements.

As items cannot be indexed, it is not possible to index MISSING items, so the EVERY operator is evaluated in the N1QL engine and cannot leverage the array index scan.

For example, <<Q8D>> below uses the primary index `def_inventory_route_primary` ignoring the {use-index-clause}[USE INDEX] hint to use the array indexes.
(Note that in this example, <<C8i>> defines a DISTINCT array index while <<C8ii>> defines an ALL array index, and both are ignored).
--

.Index II: Non-array index with an ALL array index
[[C8ii,Index II]]
[source,N1QL]
----
CREATE INDEX idx_sched_cover_all ON `travel-sample`.inventory.route
    (ALL ARRAY v.flight FOR v IN schedule END, schedule);
----

.Query D: Non-array index with an ALL array index
[[Q8D,Query D]]
[source,N1QL]
----
EXPLAIN SELECT meta().id FROM `travel-sample`.inventory.route
USE INDEX (idx_sched_cover_all, idx_sched_cover)
WHERE EVERY v IN schedule SATISFIES v.flight LIKE 'UA%' END;
----

[source,JSON]
.Result
----
[
  {
    "plan": {
      "#operator": "Sequence",
      "~children": [
        {
          "#operator": "PrimaryScan3",
          "bucket": "travel-sample",
          "index": "def_inventory_route_primary",
        // ...
        }
      ]
    }
  }
]
----
====

== Implicit Covering Array Index

N1QL supports simplified Implicit Covering Array Index syntax in certain cases where the mandatory array index-key requirement is relaxed to create a covering array-index.
This special optimization applies to those queries and DML which have WHERE clause predicates that can be exactly and completely pushed to the indexer during the array index scan.
For example:

[[example-9]]
.ANY operator with an =, <, >, and LIKE predicate in the SATISFIES clause
====
Note that the GSI indexes are tree structures that support exact match and range matches.
And the ANY predicate returns `true` as long as it finds at least one matching item in the index.
Hence, an item found in the index can cover the query.
Furthermore, this is covered by both ALL and DISTINCT array indexes.

.Index: Creating an Implicit Covering Array Index with DISTINCT
[[C9,Index]]
[source,N1QL]
----
CREATE INDEX idx_sched_cover_simple ON `travel-sample`.inventory.route
    (DISTINCT ARRAY v.flight FOR v IN schedule END);
----

.Query: Implicit Covering Array Index using the ANY clause
[[Q9,Query]]
[source,N1QL]
----
EXPLAIN SELECT meta().id FROM `travel-sample`.inventory.route
USE INDEX (idx_sched_cover_simple)
WHERE ANY v IN schedule SATISFIES v.flight LIKE 'UA%' END;
----

[source,JSON]
.Result
----
[
  {
    "plan": {
      "#operator": "Sequence",
      "~children": [
        {
          "#operator": "DistinctScan",
          "scan": {
            "#operator": "IndexScan3",
            "bucket": "travel-sample",
            "covers": [
              "cover ((distinct (array (`v`.`flight`) for `v` in (`route`.`schedule`) end)))",
              "cover ((meta(`route`).`id`))"
            ],
            "filter": "cover (any `v` in (`route`.`schedule`) satisfies ((`v`.`flight`) like \"UA%\") end)",
            "filter_covers": {
              "cover (any `v` in (`route`.`schedule`) satisfies ((\"UA\" <= (`v`.`flight`)) and ((`v`.`flight`) < \"UB\")) end)": true,
              "cover (any `v` in (`route`.`schedule`) satisfies ((`v`.`flight`) like \"UA%\") end)": true
            },
            "index": "idx_sched_cover_simple",
          // ...
          }
        }
      ]
    }
  }
]
----
====

[[example-10]]
.UNNEST operator with =, <, >, or LIKE predicate in the WHERE clause
====
This applies to only ALL array indexes because, for such index, all array elements are indexed in the array index, and the UNNEST operation needs all the elements to reconstruct the array.
Note that the array cannot be reconstructed if on DISTINCT elements of the array are indexed.

In this example, <<Q10A>> can be covered with the ALL index [.var]`idx_sched_cover_simple_all` defined by the <<C10>>, but <<Q10B>> is not covered when using the DISTINCT index [.var]`idx_sched_cover_simple` defined by the <<C9>> in <<example-9>>.

.Index: UNNEST covered with the ALL index
[[C10,Index]]
[source,N1QL]
----
CREATE INDEX idx_sched_cover_simple_all ON `travel-sample`.inventory.route
    (ALL ARRAY v.flight FOR v IN schedule END);
----

.Query A: UNNEST covered with the ALL index
[[Q10A,Query A]]
[source,N1QL]
----
EXPLAIN SELECT meta(t).id FROM `travel-sample`.inventory.route t
USE INDEX (idx_sched_cover_simple_all)
UNNEST schedule v
WHERE v.flight LIKE 'UA%';
----

[source,JSON]
.Result
----
[
  {
    "plan": {
      "#operator": "Sequence",
      "~children": [
        {
          "#operator": "IndexScan3",
          "as": "t",
          "bucket": "travel-sample",
          "covers": [
            "cover ((`v`.`flight`))",
            "cover ((meta(`t`).`id`))"
          ],
          "filter": "cover (is_array((`t`.`schedule`)))",
          "filter_covers": {
            "cover (((`t`.`schedule`) < {}))": true,
            "cover (([] <= (`t`.`schedule`)))": true,
            "cover (is_array((`t`.`schedule`)))": true
          },
          "index": "idx_sched_cover_simple_all",
          "index_id": "de0704c3fdb45b07",
          "keyspace": "route",
          "namespace": "default",
          "scope": "inventory",
          "spans": [
            {
              "exact": true,
              "range": [
                {
                  "high": "\"UB\"",
                  "inclusion": 1,
                  "low": "\"UA\""
                }
              ]
            }
          ],
          "using": "gsi"
        },
      // ...
      ]
    }
  }
]
----

.Query B: UNNEST not covered when using the DISTINCT index
[[Q10B,Query B]]
[source,N1QL]
----
EXPLAIN SELECT meta(t).id FROM `travel-sample`.inventory.route t
USE INDEX (idx_sched_cover_simple)
UNNEST schedule v
WHERE v.flight LIKE 'UA%';
----

[source,JSON]
.Result
----
[
  {
    "plan": {
      "#operator": "Sequence",
      "~children": [
        {
          "#operator": "DistinctScan",
          "scan": {
            "#operator": "IndexScan3",
            "as": "t",
            "bucket": "travel-sample",
            "index": "idx_sched_cover_simple",
            "index_id": "198a2bc8b0a3ea55",
            "index_projection": {
              "primary_key": true
            },
            "keyspace": "route",
            "namespace": "default",
            "scope": "inventory",
            "spans": [
              {
                "exact": true,
                "range": [
                  {
                    "high": "\"UB\"",
                    "inclusion": 1,
                    "low": "\"UA\""
                  }
                ]
              }
            ],
            "using": "gsi"
          }
        // ...
        }
      ]
    }
  }
]
----
====

== Summary

The following table summarizes N1QL-supported collection operators in the DML WHERE clause for different kinds of array index features:

.N1QL-supported collection operators
[cols=4*^]
|===
| Operator in the SELECT/DML WHERE clause | Array Index | Covering Array Index (with explicit array index-key) | Implicit Covering Array Index (without explicit array index-key)

| *ANY*
| ✓ (both ALL & DISTINCT)
| ✓ (both ALL & DISTINCT)
| ✓ (both ALL & DISTINCT)

| *UNNEST*
| ✓ (only ALL, with array as leading index-key)
| ✓ (only ALL, with array as leading index-key)
| ✓ (only ALL, with array as leading index-key)

| *ANY AND EVERY*
| ✓ (both ALL & DISTINCT)
| ✓ (both ALL & DISTINCT)
| ✘

| *EVERY*
| ✘
| ✘
| ✘
|===

[NOTE]
====
In Couchbase Server 6.5 and later, you can use any arbitrary alias for the right side of an UNNEST -- the alias does not have to be the same as the ARRAY index variable name in order to use that index.
====
