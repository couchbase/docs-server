= XDCR Conflict Resolution

[abstract]
_XDCR Conflict Resolution_ automatically synchronizes copies of the same
document that have been modified in different ways at different locations.

[#conflicts_and_conflict_resolution]
== Conflicts and Conflict Resolution

A _conflict_ is the modification of a document in two different
locations: the conflict must be _resolved_ by determining which
of the variants should prevail, and then saving both
documents identically, in the prevailing form. XDCR _conflict
resolution_ automates this process.

Two forms of conflict resolution are supported:
<<revision-id-based-conflict-resolution,_revision-based_>> (which is
the default),
and <<timestamp-based-conflict-resolution,_timestamp-based_>>.
Note that _timestamp-based_ conflict resolution is only available in the
Enterprise Edition of Couchbase Server.

[#the_conflict_resolution_process]
== The Conflict Resolution Process

When a source document is modified, XDCR determines whether this revision
of the document should be applied to the destination. For documents
above 256 bytes in size, XDCR fetches metadata
from the target cluster before replicating.
The target cluster metadata is compared with the metadata of the updated
document
on the source cluster, in order to choose which
should prevail (the exact subset of metadata used in this comparison
depends on the
source bucket's _conflict resolution_ policy). If the source
document prevails, it is replicated to the target; if the target document
prevails, the source document is not replicated.

Once a replicated document reaches the target, the target cluster also
performs a metadata comparison as described, in order
to confirm that the document from the source cluster should indeed
prevail. If this is confirmed, the document from the source cluster is
applied to the target cluster, and the target cluster's previous version
of the document is discarded.

As a performance optimization, XDCR makes no metadata comparison on
the source for
documents of 256 bytes or less, thus making unnecessary
a metadata-fetch from the
target cluster: instead, the document is replicated
immediately to the target, and conflict resolution is performed there.

Conflict resolution is an automatic process and does not require any manual
correction or selection of documents.

[#revision-id-based-conflict-resolution]
== Revision-Based Conflict Resolution

Revision-based conflict resolution uses the document's _revision ID_
as the first field to
resolve conflicts. Revision IDs are
maintained per document, and are incremented on every document-update.
Revision ID-based conflict resolution compares the revision IDs of the
source and target documents. The document with more revisions prevails.

For conflict resolution between an incoming mutation from another cluster and
a local mutation in the current cluster: if the incoming mutation does not
have a higher revision ID than the local mutation, it will be discarded and
will not be stored.
In the case of bidirectional replication, this process results in the mutation
with the highest revision ID taking precedence on both clusters.

Use of revision-based conflict resolution means that the document with
the more recent mutation may not prevail.

If both document-versions have the same revision ID, the
conflict is resolved by comparing the following metadata-elements, in the
order shown:

. CAS value
. Expiration (TTL) value
. Document flags

[#timestamp-based-conflict-resolution]
== Timestamp-Based Conflict Resolution

Timestamp-based conflict resolution uses the document _timestamp_
(stored in the
CAS) as the first field to resolve conflicts. The timestamps associated
with the most recent updates of source and target documents are compared.
The document whose updates bear the more
recent timestamp prevails.

For conflict resolution between an incoming mutation from another cluster and
a local mutation in the current cluster, if the incoming mutation does not have
a higher timestamp value than the local mutation, it will be discarded and will
not be stored.
In the case of bidirectional replication, this process results in the mutation
with the highest timestamp value taking precedence on both clusters.

Use of timestamp-based conflict resolution means that the document with
the greater number of mutations may not prevail.

In the event that both document versions have the same timestamp value, the
conflict is resolved by comparing the following metadata-elements, in the
order shown:

. Revision ID
. Expiration (TTL) value
. Document flags

[#time-synchronization]
==== Time Synchronization

Timestamp-based conflict resolution requires the use of _synchronized clocks_
across all nodes in all clusters intended to participate in XDCR.
If clocks are not so synchronized, document
mutations may improperly prevail as a consequence of conflict resolution.
To achieve such synchronicity, an
external entity such as NTP (Network Time Protocol) is required.
For information, see
xref:install:synchronize-clocks-using-ntp.adoc[Clock Sync with NTP].

Even with optimal clock synchronicity, small
differences may persist between the clock-settings on different nodes and
clusters:
this is known as _time skew_.
Time skew between clusters should always be closely monitored, to ensure that
timestamp-based conflict resolution functions correctly.
For more details, see
xref:xdcr-monitor-timestamp-conflict-resolution.adoc[Monitoring XDCR
Timestamp-based Conflict Resolution].

To compensate for time skew, and and to allow for updates that
could theoretically be received on the same clock tick, Couchbase Server records
time stamps using a _Hybrid Logical Clock_ (HLC).
This is a combination of a physical and a logical clock: the physical clock is
the time returned by the system, in nanoseconds; the logical clock is a counter,
which is incremented when the physical clock yields
a value either smaller or equal to the currently stored physical clock value.
The HLC:

* Is monotonic through its use of a logical clock.
This ensures that it does not suffer from the potential leap-back of a purely
physical clock.
* Captures the ordering of mutations.
* Is close to physical time.

The CAS of a document is used to store the hybrid logical clock timestamp.
It is a 64-bit value, with the most significant 48 bits representing the
physical clock, and the least significant 16 bits representing the logical clock.
Each mutation has its own hybrid logical clock timestamp.

[#use-cases]
==== Use Cases Supported by Timestamp-based Conflict Resolution

Timestamp-based conflict resolution only supports the following
use cases.

[#high_availability_with_cluster_failover]
==== High Availability with Cluster Failover

All database operations go to data center A, and are replicated to data
center B.
If the cluster located in data center A fails, the application redirects all
traffic to data center B.

image::xdcr/timestamp_clusterfailover.png[,470]

[#datacenter_locality]
==== Datacenter Locality

Two active clusters operate on discrete sets of documents.
This ensures that no conflicts are generated during normal operation.
Bidirectional replication is configured, so that each cluster
replicates its updates to the other.
When one cluster fails, application traffic is failed over to the other,
still-available cluster.

image::xdcr/timestamp_datacenter_locality.png[,470]

[#ensuring_safe_failover]
=== Ensuring Safe Failover

When failover is required,
timestamp-based conflict resolution requires that applications
redirect traffic to the still-available
cluster only after the greater of the following two time-periods has
elapsed:

* The replication latency between data centers A and B.
This provides sufficient time for any _in-flight_ mutations
to be received by data center B.
* The absolute time skew between data centers A and B.
This ensures that any writes to data center B commence after the last write to
data center A.

When availability is restored to data center A, applications must observe the
same time period, before again redirecting their traffic.
For both use cases described above, timestamp-based conflict
resolution ensures that the most recent version of each document is
preserved.

[#choosing_a_conflict_resolution_policy]
== Choosing a Conflict Resolution Policy

Conflict resolution policy is configured on a per-bucket basis at bucket
creation time, it cannot be changed later.
For more information, see xref:clustersetup:create-bucket.adoc[Create a Bucket].
Choosing a conflict resolution method requires consideration of
the logic of the applications that require the data.
This is illustrated by the following examples:

* _Most Updates Wins_: A hit-counter, for a website, is stored as a
document within Couchbase Server; a value within the document is
incremented each time the website is accessed. In the event of
conflict, the document-version that contains the higher count is the
more useful, since more closely reflective of the actual count. Therefore,
in this instance, revision-based conflict resolution is preferable, since
it ensure that the more mutated document prevails.

* _Most Recently Updated Wins_: A thermometer device store the current
temperature as a document within Couchbase Server, writing new values
continuously to the same key. In the event of conflict, the document-version
more recently updated is the more useful, since more closely reflective of
the current temperature. Therefore, in this instance, timestamp-based
conflict resolution ensures that the most recent version of the document
prevails.

[#aligning_source_and_target_conflict_resolution_policies]
== Aligning Source and Target Conflict Resolution Policies

XDCR replications cannot be created between buckets with
different conflict resolution policies: source and target
buckets must always be configured with the same policy.

When using XDCR with a source cluster running a pre-4.6 version of
Couchbase Server, only revision-based conflict resolution can be used.
