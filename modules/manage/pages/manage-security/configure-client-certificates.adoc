= Configure Client Certificates

[abstract]
Couchbase Server supports client-authentication by means of X.509
certificates.

[#couchbase-client-authentication]
== Couchbase Client Authentication

Couchbase clients can authenticate by means of X.509 certificates.
This page provides step-by-step instructions for the creation of client certificates for:

* _Couchbase Server_.
The certificate can be used by a Couchbase Server-cluster that wishes to secure its connection to another Couchbase Server-cluster.
This certificate might be used by a _source_ cluster that wishes to perform _Cross Data Center Replication_ securely, to a _destination_ cluster.

* _Java Applications_.
A Java application based on the Couchbase SDK can obtain its client certificate from a Java _keystore_, and so authenticate with Couchbase Server securely.

For a list of Couchbase-Server ports that provide secure connectivity to clients, see
xref:learn:clusters-and-availability/connectivity.adoc[Connectivity].

[#cert-auth-for-couchbase-server]
== Configure Client Certificates for Couchbase Server

The section contains two procedures for the creation of a client certificate and key, whereby authentication with Couchbase Server can be performed:

* xref:manage:manage-security/configure-client-certificates.adoc#client-certificate-authorized-by-a-root-certificate[Client Access: Root-Certificate Authorization] shows how to create a client certificate that is authorized by a cluster's root certificate.
The procedure for creating the cluster's root certificate (and, based on the root certificate, the cluster's individual per node certificates), is provided in xref:manage:manage-security/configure-server-certificates.adoc#root-and-node-certificates[Cluster Protection with Root and Node Certificates].
The instructions assume that _that_ procedure has already been followed; and duly make use of the resulting directory structure and files.

* xref:manage:manage-security/configure-client-certificates.adoc#client-certificate-authorized-by-an-intermediate-certificate[Client Access: Intermediate-Certificate Authorization] shows how to create a client certificate that is authorized by an _intermediate_ certificate; which derives its own authority from the cluster's root certificate; and which is used instead of the root for the signing of the client certificate.
The procedure for creating the cluster's root, server-intermediate and per node certificates is provided in xref:manage:manage-security/configure-server-certificates.adoc#root-intermediate-and-node-certificates[Cluster Protection with Root, Intermediate, and Node Certificates].
The instructions assume that _that_ procedure has already been followed; and duly make use of the resulting directory structure and files.

Both procedures additionally assume that the instance of Couchbase Server to be accessed by the client:

* Contains an instance of the sample bucket `travel-sample`: this is the bucket whose contents the client wishes to read and write.
For information on sample buckets and how to install them, see xref:manage:manage-settings/install-sample-buckets.adoc[Sample Buckets].

* Has a defined, locally authenticated user named `clientuser`, who has been assigned a role that permits reading and writing to the `travel-sample` bucket.
For information on creating users and roles, see xref:manage:manage-security/manage-users-and-roles.adoc[Manage Users and Roles].

Note that additional information on file-types can be found in the procedures for _server_-certificate generation; in xref:manage:manage-security/configure-server-certificates.adoc[Configure Server Certificates].

[#client-certificate-authorized-by-a-root-certificate]
=== Client Access: Root-Certificate Authorization

Proceed as follows:

. Create and access a working directory.
+
----
mkdir clientcertfiles
cd clientcertfiles
----

. Create the extensions file for the client.
+
----
cat > client.ext <<EOF
basicConstraints = CA:FALSE
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer:always
extendedKeyUsage = clientAuth
keyUsage = digitalSignature
subjectAltName = DNS:node2.cb.com,IP:10.143.192.102
EOF
----

. Create a client private key.
+
----
openssl genrsa -out ./travel-sample.key 2048
----
+
This creates the private key `travel-sample.key`, and saves it in the `client` directory.

. Generate the client-certificate signing-request.
+
----
openssl req -new -key ./travel-sample.key -out ./travel-sample.csr -subj "/CN=clientuser"
----
+
The client's private key, `travel-sample.key` is provided as input for the signing request.
The _Common Name_ provided as `Subject` for the certificate is specified as `clientuser`, which is the name of the server-defined user to be authenticated by the client.
The output request-file, `travel-sample.csr`, is saved in the `client` directory.

. Create the client certificate.
+
----
openssl x509 -CA ../ca.pem -CAkey ../ca.key \
-CAcreateserial -days 365 -req -in ./travel-sample.csr \
-out ./travel-sample.pem -extfile ../client.ext
----
+
The root certificate for the cluster, and its corresponding private key, `ca.pem` and `ca.key` are specified as inputs for certificate generation.
This ensures that the root certificate will be incorporated into the client certificate, with a digital signature that can be deciphered by means of the public key within the root certificate, thereby establishing the client's chain of authority.
+
The file containing extensions is specified as the value of the `extfile` flag.
The output file, `travel-sample.pem`, is the client certificate, and is saved in `clientdir`.

This concludes the process.
The client can now use `travel-sample.pem` to authenticate itself as having the authority of `ca.pem` (which is shared by the server it intends to access); and provides the username of `clientuser` (which the server associates with a role appropriate for access to the `travel-sample` bucket).
The client key, `travel-sample.key`, can be used for digital signing.

[#client-certificate-authorized-by-an-intermediate-certificate]
=== Client Access: Intermediate-Certificate Authorization

Proceed as follows:

. Access the `servercertfiles2/root` directory, created in xref:manage:manage-security/configure-server-certificates.adoc#root-intermediate-and-node-certificates[Cluster Proection with Root, Intermediate, and Node Certificates].
+
----
cd servercertfiles2/root
----

. Create a certificate signing request for an intermediate certificate to be used for signing client certificates.
+
----
openssl req -new -sha256 -newkey rsa:2048 -keyout ../clients/ca.key \
-out reqs/client-signing.csr \
-subj '/C=UA/O=MyCompany/OU=People/CN=ClientSigningCA'
----
+
This command specifies a new private key for the request, named `../clients/ca.key`.
The signing-request file is saved as `reqs/client-signing.csr`.

. Create the intermediate certificate to be used for client-certificate signing.
+
----
openssl x509 -CA ca.pem -CAkey ca.key -CAcreateserial -CAserial serial.srl \
-days 3650 -req -in reqs/client-signing.csr -out issued/client-signing.pem \
-extfile ca.ext
----
+
The root certificate and key for the cluster, `ca.pem` and `ca.key`, are specified as the authority for the intermediate certificate.
The extension file used to constrain the capabilities of the intermediate certificate is that created in xref:manage:manage-security/configure-server-certificates.adoc#create-intermediate-extensions-file[Cluster Proection with Root, Intermediate, and Node Certificates].

. Save the intermediate certificate as the certificate-authority for the client certificate that is to be created.
+
----
cp issued/client-signing.pem ../clients/ca.pem
----

. Change directory to `../clients`, and create an extension file for the client certificate:
+
----
cd ../clients

cat > client.ext <<EOF
basicConstraints = CA:FALSE
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer:always
extendedKeyUsage = clientAuth
keyUsage = digitalSignature
EOF
----
+
The value of `extendedKeyUsage` is specified as `clientAuth`, indicating that the certificate will be used to authenticate a client.
The value of `keyUsage` is specified as `digitalSignature`, indicating that the certificate may be used in the verifying of information-origin.

. Create a private key for the client certificate.
+
----
openssl genrsa -out private/clientuser.key 2048
----

. Create a certificate signing request for the client certificate.
+
----
openssl req -new -key private/clientuser.key -out reqs/clientuser.csr \
-subj "/C=UA/O=MyCompany/OU=People/CN=clientuser"
----
+
The signing request is based on the private key `clientuser.key`.
The username associated with the certificate is specified as `clientuser`: this is the username to be recognized by Couchbase Server, and associated with specific roles.

. Create the client certificate.
+
----
openssl x509 -CA ca.pem -CAkey ca.key -CAcreateserial -CAserial serial.srl \
-days 365 -req -in reqs/clientuser.csr \
-out issued/clientuser.pem -extfile client.ext
----
+
This creates the client certificate `clientuser.pem`, based on the signing request `clientuser.csr`, and signed with the authority of the intermediate certificate and key, `ca.pem` and `ca.key`.
The certificate is saved in the `issued` folder.

. Check the validity of the client certificate.
The following use of the `openssl` command verifies the relationship between the root certificate, the client-intermediate certificate, and the client certificate.
+
----
openssl verify -trusted ../root/ca.pem -untrusted ca.pem \
issued/clientuser.pem
----
+
If the certificate is valid, the following output is displayed:
+
----
issued/clientuser.pem: OK
----

. Concatenate the issued client certificate with the client-intermediate certificate, to establish the chain of authority.
+
----
cat issued/tony.hillman@couchbase.com.pem ca.pem > clientuser.pem
----
+
The result of the concatenation, `clientuser.pem` is the completed client certificate.

[#using-client-and-server-certificates-for-secure-xdcr]
=== Using Client and Server Certificates for Secure XDCR

Examples of using the certificates and keys created on this page and on xref:manage:manage-security/configure-server-certificates.adoc[Configure Server Certificates] can be found in xref:manage:manage-xdcr/enable-full-secure-replication.adoc#specify-full-xdcr-security-with-certificates[Specify Root and Client Certificates, and Client Private Key].

[#cert_auth_for_java_client]
== Configure a Client Certificate for a Java Client

A _Java_ client uses a _keystore_ to access the certificates it requires for authentication.
This allows the client to access all Couchbase Services.
Certificate and keystore preparation is demonstrated by the following instructions; which are based on the same assumptions as those listed above, in xref:manage:manage-security/configure-client-certificates.adoc#cert-auth-for-couchbase-server[Configure a Client Certificate for Couchbase Server].

Proceed as follows:

. Define environment variables for the name of the keystore to be created, and its password.
+
[source,bash]
----
export KEYSTORE_FILE=my.keystore
export STOREPASS=storepass
----

. If necessary, install a package containing the `keytool` utility:
+
[source,bash]
----
sudo apt install openjdk-9-jre-headless
----

. Within the top-level, `SSLCA` directory that you created, generate the keystore.
Note that the password you specify for the alias, by means of the `--keypass` flag, must be identical to the password you specify for the keystore, by means of the `--storepass` flag.
In this case, both passwords are specified as `&#36;&#123;STOREPASS&#125;`; which resolves to `storepass`.
+
[source,bash]
----
keytool -genkey -keyalg RSA -alias selfsigned \
-keystore ${KEYSTORE_FILE} -storepass ${STOREPASS} -validity 360 -keysize 2048 \
-noprompt  -dname "CN=${USERNAME}, OU=None, O=None, L=None, S=None, C=US" -keypass ${STOREPASS}
----

. Generate the certificate signing-request:
+
[source,bash]
----
keytool -certreq -alias selfsigned -keyalg RSA -file my.csr \
-keystore ${KEYSTORE_FILE} -storepass ${STOREPASS} -noprompt
----

. Generate the client certificate, signing it with the intermediate private key:
+
[source,bash]
----
openssl x509 -req -in my.csr -CA ./${INT_DIR}/${INTERMEDIATE}.pem \
-CAkey ./${INT_DIR}/${INTERMEDIATE}.key -CAcreateserial -out clientcert.pem -days 365
----

. Add the root certificate to the keystore:
+
[source,bash]
----
keytool -import -trustcacerts -file ./${ROOT_DIR}/${ROOT_CA}.pem \
-alias root -keystore ${KEYSTORE_FILE} -storepass ${STOREPASS} -noprompt
----

. Add the intermediate certificate to the keystore:
+
[source,bash]
----
keytool -import -trustcacerts -file ./${INT_DIR}/${INTERMEDIATE}.pem \
-alias int -keystore ${KEYSTORE_FILE} -storepass ${STOREPASS} -noprompt
----

. Add the client certificate to the keystore:
+
[source,bash]
----
keytool -import -keystore ${KEYSTORE_FILE} -file clientcert.pem \
-alias selfsigned -storepass ${STOREPASS} -noprompt
----

This concludes preparation of the Java client's keystore.
Copy the file (in this case, `my.keystore`) to a location on a local filesystem
from which the Java client can access it.

[#enabling-client-security]
== Securing Client Access with TLS

For an application to communicate securely with Couchbase Server, SSL/TLS must
be enabled on the client side.
Enablement requires a copy of the certificate used by Couchbase Server: this can be accessed from the Couchbase Web Console, as described in
xref:manage:manage-security/manage-security-settings.adoc#root-certificate-security-screen-display[Root
Certificate].

Note that if, at some point, this certificate gets regenerated on the server-side, a copy of the new version must be obtained, and the client re-enabled.
