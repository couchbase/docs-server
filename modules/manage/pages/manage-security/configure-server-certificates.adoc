= Configure Server Certificates

[abstract]
Couchbase Server Enterprise Edition supports X.509 certificates, for
the encryption of communications between the server and
networked clients.

[#configure-server-side-certificates]
== Configure Server Certificates

This section demonstrates how server certificates can be configured for Couchbase Server.
Note that the procedures are provided only as _limited examples_, giving guidance as to the basic steps typically involved in certificate creation.
Modification of the procedures will likely be required, for the preparation of certificates for different platforms and cluster-configurations.

Before attempting to follow the procedures, see the conceptual and architectural information provided in xref:learn:security/certificates.adoc[Certificates].

The procedures configure X.509 certificates on Ubuntu 16, for a one-node Couchbase Server-cluster.
The `sudo` command should be used where appropriate.

Two procedures are provided.
The first, xref:manage:manage-security/configure-server-certificates.adoc#root-and-node-certificates[Example with Root and Node Certificates], is the simpler: it shows how to create a root certificate that is the trusted, self-signed authority used to sign individual, per node certificates. The second, xref:manage:manage-security/configure-server-certificates.adoc#root-intermediate-and-node-certificates[Example with Root, Intermediate, and Node Certificates], demonstrates how the the root certificate is used to sign an _intermediate_ certificate, which is in turn used to sign the individual, per node certificates: use of an intermediate certificate allows the root certificate to be kept out of circulation, and thereby maintained more securely.

[#root-and-node-certificates]
=== Example with Root and Node Certificates

Proceed as follows:

. On the server to be certificate-protected, create working directories:
+
----
mkdir certfiles
cd certfiles
mkdir -p {public,private,requests}
----
+
The `public` directory will be used to store _certificates_, which contain _public_ keys.
The `private` directory will contain _private_ keys.
The `requests` directory will store certificate _signing requests_, which are files generated from private keys for subsequent signing, as _certificates_, by an appropriate authority.



. Create a _private key_ for the cluster.
+
A private key can be used to decrypt data previously encrypted by the corresponding _public_ key.
It can also be used to encrypt a _digital signature_, to be decrypted by the public key.
In the key-creation sequence, the private key is created first.
Then, the public key is created, being _derived from_ the private key.
+
Enter the following:
+
----
openssl genrsa -out ca.key 2048
----
+
The output of this command, `ca.key`, is the private key for the cluster.

. Create the _certificate_ (that is, the file that will contain the public key) for the cluster.
The certificate is intended to be _self-signed_, meaning that it will not be vouched for by any other authority.
This means that it can be created directly, based on the existing private key `ca.key`, without assistance from a third party.
+
Enter the following:
+
----
openssl req -new -x509 -days 3650 -sha256 -key ca.key -out ca.pem \
-subj "/CN=Couchbase Root CA"
----
+
The `x509` flag indicates that an x509 structure, rather than a _request_ should be generated.
(A request is needed when the certificate must be signed by a third-party authority, as is demonstrated below.)
The `days` flag specifies the number of days for which the certificate should be active.
The hashing algorithm to be used for digital-signature creation is specified as `sha256`.
The private key file on which the certificate is to be based is specified as `ca.key`, and the output-certificate is named as `ca.pem`.
The certificate's _issuer_ is specified to have the `CN` (_Common Name_) of `Couchbase Root CA`: as this indicates, the certificate will be the _root_ certificate for the Couchbase Server-cluster.
+
The output of the command is the certificate `ca.pem`.
This contains the public key that corresponds to the cluster's private key, `ca.key`.
+
Optionally, the public key within the certificate can be displayed as follows:
+
----
openssl x509 -in ./ca.pem -noout -pubkey
----
+
The output has approximately the following appearance:
+
----
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA3HMfiSjCwakfMbA20HUd
V372JbQG9UGjf9V3xyMa90IHFD8cFjPYao7SZOpe0nkm2UmZRgQbTwWxC4CZqrYZ
pyrWLn9rjDFkzzbRjMRcZv2D0s0KkPrNYxfHj3cL/j5bpB4/hquvb4RglMkyyJo9
mVx19lF4mtEsBqPGZBGArbzeArn4c1e6I4mqIfb9Vne/7vhIzLLSXoT5FmifWyGQ
4B9BSIrE9Ildwhez699MGfj+N+0xg2wTOIUVNvS1c5gF/uDS6t9Aswb60W+hjtF4
d1ZBKBIVkmPGX0XOgGtdndXza4sjVkh3bB/ipWo9zUJYwFCWkofbqGeSnSz9n9o6
fwIDAQAB
-----END PUBLIC KEY-----
----
+
Note that by substituting other flags for `pubkey`, other characteristics of the certificate can be displayed.
`issuer` displays the certificate's issuer, and `subject` its subject (in both cases, `subject= /CN=Couchbase Root CA`).
The `version`, `serial`, `subject-hash`, and more can be displayed.
+
The _entire certificate_ can be displayed as text, by means of the following command:
+
----
openssl x509 -text -noout -in ./ca.pem
----
+
The initial part of the output, which is extensive, is as follows:
+
----
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 18276610881715621025 (0xfda390c366b2cca1)
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: CN=Couchbase Root CA
        Validity
            Not Before: Sep  2 08:32:31 2019 GMT
            Not After : Aug 30 08:32:31 2029 GMT
        Subject: CN=Couchbase Root CA
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    00:d7:a6:ba:5d:e2:e2:fd:6e:1b:33:9a:4b:bf:77:
                    6f:28:c3:37:60:33:da:09:b2:0b:73:1f:f9:65:2a:
                                  .
                                  .
----
+
The displayed text thus provides information including the `Version`, the `Serial Number`, and the `Signature Algorithm` of the certificate.
The certificate's `Issuer`, `Subject`, and period of `Validity` are also shown.
The `Algorithm` and `Modulus` (and, further below, the `Exponent`) of the public key are shown.
+
For detailed information on keys and key-generation, see https://en.wikipedia.org/wiki/RSA_(cryptosystem)[RSA (cryptosystem)].

. Create a private key for the server node.
+
In addition to the root certificate and private key for the entire cluster, which are `ca.pem` and `ca.key`, a _node_ certificate and private key must also be created.
The node certificate and private key will reside on each node of the cluster.
The node certificate will specify the root certificate, `ca.pem`, as its issuer; and thereby record the chain of authority whereby clients may choose to trust it.
When deployed, the node certificate must be named `chain.pem`, and the node private key `pkey.key`: however, if the node certificates and private keys for multiple cluster-nodes are being prepared on a single system, they need to be given individual, distinctive names on creation; and then deployed on each respective cluster node as `chain.pem` and `pkey.key` &#8212; this renaming procedure is indeed followed here for demonstration purposes, even though only a one-node cluster is involved.
+
Create the node private key as follows:
+
----
openssl genrsa -out private/couchbase.default.svc.key 2048
----
+
The output file is `couchbase.default.svc.key`, which is the private key for the node.

. Create a certificate signing request for the node certificate.
This step allows the materials required for certificate-creation to be passed to a third-party, who will _digitally sign_ the certificate as part of its creation-process, and thereby confirm its validity.
(In this demonstration, however, no third-party is involved: the certificate will be signed, below, by the current user.)
+
Enter the following command:
+
----
openssl req -new -key private/couchbase.default.svc.key \
-out requests/couchbase.default.svc.csr -subj "/CN=Couchbase Server"
----
+
The `key` specified as the input for the request is `couchbase.default.svc.key`, which was created in the last step.
The output request-file is specified as `couchbase.default.svc.csr`.
Note that the request file can be inspected as text, by entering the following command:
+
----
openssl req -text -noout -verify -in ./requests/couchbase.default.svc.csr
----
+
The initial part of the displayed output, which is extensive, is as follows:
+
----
verify OK
Certificate Request:
    Data:
        Version: 0 (0x0)
        Subject: CN=Couchbase Server
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    00:be:26:e5:06:c6:8e:43:bb:9d:bc:84:20:34:8e:
                    db:2f:d1:8b:b4:ff:c2:66:c0:61:70:8d:c3:8c:df:
                                      .
                                      .
----
+
The `Version` and `Subject` of the request are listed, along with information on the public key to be included in the certificate.

. Define _certificate extensions_ for the node.
+
Certificate extensions specify requirements for how a certificate is to be used: all specified requirements must be met, for the certificate to be usable.
This step allows the extensions to be submitted to a signing authority, along with the certificate signing request.
+
For example, the certificate's public key can be specified, by means of the `keyUsage` extension, to support _digital signatures_, but _not_ to support _key encipherment_ &#8212; or, _the opposite_ can be specified; or, support of _both_ digital signatures _and_ key encipherment can be specified.
Meanwhile, the `subjectAltName` extension can be used to specify the _DNS name_ and _IP address_ of the server on which the certificate resides; so that if the certificate is deployed in any other context, it becomes invalid.
+
For detailed information on certificate extensions, see the https://tools.ietf.org/html/rfc5280#section-4.2.1[Standard Extensions] section of the https://tools.ietf.org/html/rfc5280[Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL Profile)].
+
Certificate extensions can be specified by means of a file, provided as a parameter to the `openssl` command that is used to create the certificate.
Thus, the server-certificate extensions that are generic across all servers in the cluster might be written as follows:
+
----
cat > server.ext <<EOF
basicConstraints=CA:FALSE
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer:always
extendedKeyUsage=serverAuth
keyUsage = digitalSignature,keyEncipherment
subjectAltName = DNS:node2.cb.com,IP:10.143.192.102
EOF
----
+
Note that these extensions assume that the DNS name of the server-node is `node2.cb.com`, and its IP address is `10.143.192.102`.
If experimentation is being performed locally, the `/etc/hosts` file for the local machine should contain a line such as the following:
+
----
10.143.192.102  node2.cb.com
----

. Create the node certificate, applying the certificate and digital signature of the appropriate authority, and the file containing the extensions for the node, to the materials in the signing request.
+
Enter the following:
+
----
openssl x509 -CA ca.pem -CAkey ca.key -CAcreateserial -days 365 -req \
-in requests/couchbase.default.svc.csr \
-out public/couchbase.default.svc.pem \
-extfile server.ext
----
+
The output from this command, the file `couchbase.default.svc.pem`, is the node certificate.
The root certificate and private key, `ca.pem` and `ca.key`, are specified as input values to the certificate-creation command.
This ensures that the new certificate's chain of trust includes the root certificate, `ca.pem`, and is digitally signed by `ca.key`; allowing that signature to be verified as required, through decipherment by means of the public key embedded in `ca.pem`.
+
Note that if a node certificate were actually submitted to an external authority for signing, then the authority's own `pem` and `key` would be specified as inputs, rather than `ca.pem` and `ca.key`: and in such a case, the authority's `pem` would need to become the root certificate for the cluster.

. Rename the node certificate and node private key.
+
For deployment on the node, the node certificate must be renamed `chain.pem`; and the node private key renamed `pkey.key`.
Proceed as follows:
+
----
cd ./public
mv couchbase.default.svc.pem chain.pem
cd ../private
mv couchbase.default.svc.key pkey.key
----

. Deploy the node certificate and node private key.
+
These are deployed by being moved to the `inbox` directory of the server, and made _executable_.
Proceed as follows:
+
----
cd ..
sudo mkdir /opt/couchbase/var/lib/couchbase/inbox/
sudo cp ./public/chain.pem /opt/couchbase/var/lib/couchbase/inbox/chain.pem
sudo chmod a+x /opt/couchbase/var/lib/couchbase/inbox/chain.pem
sudo cp ./private/pkey.key /opt/couchbase/var/lib/couchbase/inbox/pkey.key
sudo chmod a+x /opt/couchbase/var/lib/couchbase/inbox/pkey.key
----

. Upload and activate the root certificate for the cluster.
+
The root certificate is uploaded and activated with the following REST commands:
+
----
curl -X POST --data-binary "@./ca.pem" \
http://Administrator:password@10.143.192.102:8091/controller/uploadClusterCA

curl -X POST \
http://Administrator:password@10.143.192.102:8091/node/controller/reloadCertificate
----
+
The root certificate is now deployed and ready for use.
This can be verified by means of Couchbase Web Console.
Access the *Security* screen, by means of the *Security* tab in the left-hand navigation bar.
Then, left-click on the *Root Certificate* tab, located on the upper, horizontal navigation bar.
[#see-root-certificate-with-couchbase-web-console]
The screen appears as follows:
+
image::manage-security/rootCertificateWithSignedCert.png[600,align=left]
+
As this indicates, the signed certificate has now been substituted for the default certificate (an example of whose appearance is provided in xref:manage:manage-security/manage-security-settings.adoc#root-certificate-security-screen-display[Root Certificate]).

Note that authentication by means of a client certificate must be specifically enabled: see xref:manage:manage-security/configure-server-certificates.adoc#client-certificate-enablement[Client Certificate Enablement], below.

[#root-intermediate-and-node-certificates]
=== Example with Root, Intermediate, and Node Certificates

Optionally, a root certificate can be used to sign an _intermediate_ certificate, which is then itself used to sign node certificates.
This allows the root certificate to be kept out of circulation, and thereby maintained more securely.

The steps and descriptions below assume that the previous procedure, xref:manage:manage-security/configure-server-certificates.adoc#root-and-node-certificates[Example with Root and Node Certificates], has already been successfully completed.

Proceed as follows:

. On the server to be certificate-protected, create working directories:
+
----
mkdir certfiles2
cd certfiles2
mkdir -p {root,servers,clients}/{issued,reqs,private}
----

. Change directory to `root`.
Then, create a configuration file for the root certificate that is to be created.
+
----
cd root

cat > config <<EOF
[req]
distinguished_name = cn_only
x509_extensions = ca_ext
[ cn_only ]
commonName = Common Name (eg: your user, host, or server name)
commonName_max = 64
commonName_default = CA
[ca_ext]
basicConstraints = CA:TRUE
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid:always,issuer:always
keyUsage = cRLSign, keyCertSign
EOF
----

. Create the root certificate.
+
----
openssl req -config config -new -x509 -days 3650 -sha256 -newkey rsa:2048 \
-keyout ca.key -out ca.pem -subj '/C=UA/O=MyCompany/CN=RootCA'
----

. Create an extensions file that will limit the capabilities of the _intermediate_ certificate that is to be created.
+
----
cat > ca.ext <<EOF
basicConstraints = CA:TRUE
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid:always,issuer:always
keyUsage = cRLSign, keyCertSign
EOF
----
+
Here, `CA` is set to `TRUE`, meaning that the intermediate certificate will be able to act as an authority for other certificates (specifically, for the individual, per node certificates used by the cluster).
The specified `keyUsage` includes the value `keyCertSign`, meaning that the intermediate certificates private key will be used to sign the certificates for which it will act as an authority.

. Create a certificate signing request for the intermediate certificate.
+
----
openssl req -new -sha256 -newkey rsa:2048 -keyout ../servers/ca.key \
-out reqs/server-signing.csr \
-subj '/C=UA/O=MyCompany/OU=Servers/CN=ServerSigningCA'
----
+
The output from the request is the signing-request file, `server-signing.csr`.

. Create the intermediate certificate:
+
----
openssl x509 -CA ca.pem -CAkey ca.key -CAcreateserial \
-CAserial serial.srl -days 3650 -req -in reqs/server-signing.csr \
-out issued/server-signing.pem -extfile ca.ext
----
+
This applies the extension file `ca.ext` to the certificate, so as to limit the certificate's capabilities.
The certificate is output as `server-signing.pem`.

. Save the intermediate certificate as the authority for the node certificates that are to be created.
+
----
cp issued/client-signing.pem ../clients/ca.pem
----

. Create an extension file containing the information that will be generic across the individual nodes of the cluster.
+
----
cat > server.ext <<EOF
basicConstraints = CA:FALSE
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer:always
extendedKeyUsage = serverAuth
keyUsage = digitalSignature,keyEncipherment
EOF
----
+
Although the current example uses a single-node cluster, the information in the extension file could be applied to multiple nodes, if the cluster were incremented in size.
The `extendedKeyUsage` value `serverAuth` indicates that the certificate will be used for server authentication.
The `keyUsage` value `digitalSignature` specifies that the certificate's public key can be used in the verifying of information-origin; while `keyEncipherment` allows the public key to be used in the encrypting of symmetric keys.

. Generate the private key to be used for each, individual server node.
+
----
openssl genrsa -out private/couchbase.node.svc.key 2048
----

. Generate the certificate signing request for the node certificate.
+
----
openssl req -new -key private/couchbase.node.svc.key \
-out reqs/couchbase.node.svc.csr \
-subj "/C=UA/O=MyCompany/OU=Servers/CN=couchbase.node.svc"
----

. Add node-specific information for each node, in turn.
Although the current example features a single-node cluster, this step should be repeated for each node in the cluster, when the cluster contains multiple nodes.
In each case, the node-specific information (here, DNS name and IP address) will be different.
+
----
cp server.ext temp.ext

echo 'subjectAltName = DNS:node2.cb.com,IP:10.143.192.102' >> temp.ext
----

. Create the node certificate for an individual node, specifying the unique extension file for the node.
+
----
openssl x509 -CA ca.pem -CAkey ca.key -CAcreateserial \
-CAserial serial.srl -days 365 -req -in reqs/couchbase.node.svc.csr \
-out issued/couchbase.node.svc.pem -extfile temp.ext
----

. Check that the node certificate is valid.
The following `openssl` command verifies the relationship between the root certificate, the intermediate certificate, and the node certificate.
+
----
openssl verify -trusted ../root/ca.pem -untrusted ca.pem issued/couchbase.node.svc.pem
----
+
If the certificate is valid, the following output is displayed:
+
----
issued/couchbase.node.svc.pem: OK
----

. Prepare to deploy certificate and private key for the node.
First, concatenate the node certificate and the root certificate, to establish the chain of authority.
Then, rename the private key for the node.
+
----
cat issued/couchbase.node.svc.pem ca.pem > chain.pem

cp private/couchbase.node.svc.key pkey.key
----
+
This step, and each of the following steps in this procedure, must be performed for each node in the cluster.

. Move the node certificate and node private key into the `inbox` for the node.
+
----
sudo mkdir /opt/couchbase/var/lib/couchbase/inbox/  # if needed

sudo cp ./chain.pem /opt/couchbase/var/lib/couchbase/inbox/chain.pem
sudo chmod a+x /opt/couchbase/var/lib/couchbase/inbox/chain.pem
sudo cp ./pkey.key /opt/couchbase/var/lib/couchbase/inbox/pkey.key
sudo chmod a+x /opt/couchbase/var/lib/couchbase/inbox/pkey.key
----

. Upload and activate the root certificate.
+
----
cd ../root

curl -X POST --data-binary "@./ca.pem" \
http://Administrator:password@10.143.192.102:8091/controller/uploadClusterCA

curl -X POST http://Administrator:password@10.143.192.102:8091/node/controller/reloadCertificate
----

This concludes the certificate-deployment process.
The root certificate can be examined by means of Couchbase Web Console, as shown in xref:manage:manage-security/configure-server-certificates.adoc#see-root-certificate-with-couchbase-web-console[Step 10] of the previous example on this page.

Note that authentication by means of a client certificate must be specifically enabled: see xref:manage:manage-security/configure-server-certificates.adoc#client-certificate-enablement[Client Certificate Enablement], immediately below.

[#client-certificate-enablement]
== Client-Certificate Enablement

As well as _providing_ a certificate _to_ clients for purposes of authentication and encryption, Couchbase Server may also _receive_ certificates _from_ clients, allowing the clients to authenticate themselves.
The handling of client certificates by the server must be explicitly enabled.
For information on enablement options and identity encodings, see xref:learn:security/certificates.adoc#client-certificates[Client Certificates].
For an introduction to the user interface provided by Couchbase Web Console, see xref:manage:manage-security/manage-security-settings.adoc#client-certificate-security-screen-display[Client Certificate].
For information on performing enablement with Couchbase Web Console, the CLI, and the REST API, see
xref:manage:manage-security/enable-client-certificate-handling.adoc[Enable Client-Certificate Handling].

The REST API might be used to enable client-certificate handling as follows:

----
curl -u Administrator:password -v -X POST \
http://10.143.192.102:8091/settings/clientCertAuth \
-d '{"state": "enable","prefixes": [{"path": \
"subject.cn","prefix": "","delimiter": ""}]}'
----

[#further-information]
== Further Information

For further information on certificate-deployment, see xref:cli:cbcli/couchbase-cli-ssl-manage.adoc[ssl-manage] and xref:rest-api:rest-encryption.adoc[Encryption On-the-Wire API].

For step-by-step instructions on creating _client_ certificates, see xref:manage:manage-security/configure-client-certificates.adoc[Configure Client Certificates].

For an example of using the certificates and keys created on the current page and on xref:manage:manage-security/configure-client-certificates.adoc[Configure Client Certificates] to secure an _XDCR replication_, see xref:manage:manage-xdcr/enable-full-secure-replication.adoc#specify-full-xdcr-security-with-certificates[Specify Root and Client Certificates, and Client Private Key].
