= Configure Server Certificates
:description: Couchbase Server Enterprise Edition supports using X.509 and PKCS #12 certificates for authenticating and encrypting data between the nodes in the cluster.

[abstract]
{description}

This page explains how to configure server certificates for Couchbase Server Enterprise Edition.
For an overview of how Couchbase Server uses certificates, see  xref:learn:security/certificates.adoc[Certificates].

The procedures in this page are only limited examples.
They cover the basic steps for creating certificates.
When creating and deploying certificates for your own database, you often have to modify these steps to suit your environment.

This page gives detailed steps to configure X.509 certificates on a Linux-based single node Couchbase Server. 
It demonstrates two scenarios. 
The first shows directly signing the node's certificate using the cluster's certificate. 
The second shows creating an intermediate certificate from the cluster certificate and using that to sign the node's certificate.

This page also explains how you can bundle certificates, private keys, and certificate chains into a single Public-Key Cryptography Standard (PKCS) #12 certificate file.
Couchbase Server supports using this type of file to upload node certificates.

NOTE: Once you deploy cluster and node certificates to a database, you must create additional node certificates for any new nodes you add later.
See xref:manage:manage-security/configure-server-certificates.adoc#adding-new-cluster-nodes[Adding New Cluster Nodes] for details.

[#root-and-node-certificates]
== Create and Deploy Cluster and Node Certificates

The following procedure shows how to create a  self-signed root certificate for a single-node database.
It then demonstrates using that certificate to sign a node certificate.
The steps for a multi-node cluster are similar, as explained at the end of the example.

. Open a command line shell on the node.

. In some directory--such as your home directory or `/tmp`--create working directories:
+
[source, console]
----
mkdir servercertfiles
cd servercertfiles
mkdir -p {public,private,requests}
----
+
In this example, each directory has a different purpose:
+
* The `public` directory stores certificates, which contain public keys.
* The `private` directory contains private keys.
* The `requests` directory stores certificate signing requests. 

. Create a private key for the cluster:
[source, console]
+
----
openssl genrsa -out ca.key 2048
----
+
The output of this command, `ca.key`, is the private key for the cluster.

. Create the certificate (the file that contains the public key) for the cluster:
+
[source, console]
----
openssl req -new -x509 -days 3650 -sha256 -key ca.key -out ca.pem \
        -subj "/CN=Couchbase Root CA"
----
+
The arguments to this command are:
+
* `-x509`: generates an x509 format certificate.
* `-days 3650`: the number of days before the certificate expires.
* `-sha256` the hashing algorithm to use for the digital signature.
* `-key ca.key`: sets the private key file the certificate is based on to the private key you cteated in the previous step. 
* `-out ca.pem`: the filename for the certificate.
* `-subj "/CN=Couchbase Root CA"`: `/CN=` portion of the argument sets the common name of the certificate's issuer to `Couchbase Root CA`.
This name identifies the certificate as the root certificate for the Couchbase Server cluster.

. Optionally, you can review the content of the certificate you just created using the command:
+
[source, console]
----
openssl x509 -text -noout -in ./ca.pem
----
+
The following is an example of the first part of the output:
+
----
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 18276610881715621025 (0xfda390c366b2cca1)
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: CN=Couchbase Root CA
        Validity
            Not Before: Sep  2 08:32:31 2019 GMT
            Not After : Aug 30 08:32:31 2029 GMT
        Subject: CN=Couchbase Root CA
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    00:d7:a6:ba:5d:e2:e2:fd:6e:1b:33:9a:4b:bf:77:
                    6f:28:c3:37:60:33:da:09:b2:0b:73:1f:f9:65:2a:
                                  .
                                  .
----
+
For detailed information about keys and key generation, see https://en.wikipedia.org/wiki/RSA_(cryptosystem)[RSA (cryptosystem)].

. Create a private key for the node.
Each node in the cluster needs its own private key and certificate. 
Couchbase Server requires that you name the file containing private key `pkey.key`.
However, if you're creating private keys for multiple nodes, you'll need to give them unique filenames to avoid them overwriting each other.
This example gives it a unique name, which you'll need to change when you deploy the private key to the node.
+
The command to create a private key is:
+
[source, console]
----
openssl genrsa -out private/couchbase.default.svc.key 2048
----

. Create a Certificate Signing Request (CSR) for the node certificate:
+
[source, console]
----
openssl req -new -key private/couchbase.default.svc.key \
        -out requests/couchbase.default.svc.csr -subj "/CN=Couchbase Server"
----
+
This step prepares the request you use to sign the node's certificate with the cluster's private key and certificate later.

. Define the certificate extensions for all nodes.
These extensions define constraints on how a certificate can be used.
For detailed information about certificate extensions, see the https://tools.ietf.org/html/rfc5280#section-4.2.1[Standard Extensions] section of the https://tools.ietf.org/html/rfc5280[Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL Profile)].
You submit the extensions to the signing CA, along with the CSR you generated in the previous step.
This example creates a text file containing the extensions that are common to all nodes in the cluster.
The next step adds information specific to an individual node.
+
Use this command to create the certificate extension file:
+
[source, console]
----
cat > server.ext <<EOF
basicConstraints=CA:FALSE
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer:always
extendedKeyUsage=serverAuth
keyUsage = digitalSignature,keyEncipherment
EOF
----
+
The extensions in this file are:
+
* `basicConstraints=CA:FALSE`: the certificate generated from the CSR cannot be used to issue other certificates.
* `subjectKeyIdentifier = hash`: the Subject Key Identifier (SKI) is derived form a hash of the public key in the certificate.
* `authorityKeyIdentifier = keyid,issuer:always`: specifies how to generate Authority Key Identifier (AKI).
The `keyid` tells the certificate signing process to generate the AKI from the issuer's public key (the cluster's public key, in this example). 
The `issuer:always`: means that the signing process always includes the issuer's distinguished name (DN)in the AKI.
* `extendedKeyUsage=serverAuth`: means that the purpose of the certificate being signed is for server identification. 
* `keyUsage`: limits how the private key can be used. The values `digitalSignature,keyEncipherment` mean you can use the private key for digital signatures and for encipherment.
Encipherment means that the key's primary use is to encrypt session or  symmetric keys, but it can also be used for direct data encryption. 

. Create a customized version of the certificate extensions file that containing settings specific to the node:
+
[source, console]
----
cp ./server.ext ./server.ext.tmp

echo "subjectAltName = IP:10.143.192.102" \
>> ./server.ext.tmp
----
+
This command copies the file created in the previous step and adds a `subjectAltName` extension that identifies the node.
This example uses the node's IPv4 address. 
This extension makes sure the node's certificate is valid for just the specific node. 
No other node or client can use the certificate.
If your cluster uses DNS names to identify nodes, you must use the node's DNS name, such as `DNS:node2.cb.com` instead of its IP address. 
+
NOTE: Couchbase Enterprise Server Version 7.2 and later requires that the node's certificate identifies the node in a Subject Alternative Name extension.
Without this identification, Couchbase Server reports an error when you upload the certificate to the node or when you try to add the node to the cluster. 
For more information, see xref:learn:security/certificates.adoc#node-certificate-validation[Node-Certificate Validation].

. Create the node's certificate by signing it with the certificate and digital signature of the CA.
In this example, the CA is the cluster, so the command to sign the node's certificate uses the cluster's key and certificate:
+
[source, console]
----
openssl x509 -CA ca.pem -CAkey ca.key -CAcreateserial -days 365 -req \
-in requests/couchbase.default.svc.csr \
-out public/couchbase.default.svc.pem \
-extfile server.ext.tmp
----
+
The arguments to this command are:
+
--
* `x509`: specifies that `openssl` should create an x509 certificate.
* `-CA ca.pem -CAkey ca.key`: sets the CA's key and certificate to be ones created for the cluster in steps 1 and 2.
* `-CAcreateserial`: tells `openssl` to create a serial number file if it does not already exist.
It then writes the serial number it assigns to the certificate to this file.
The serial file records the serial numbers of all the certificates `openssl` creates to make sure each certificate it creates has a unique serial number.  
* `-days 365`: sets the number of days before the certificate expires.
* `-req`: tells `openssl` that you want to read a CSR to perform a certificate signing.
* `-in requests/couchbase.default.svc.csr`: has `openssl` read the CSR created in step 6.
* `out public/couchbase.default.svc.pem`: tells `openssl` sets where to save the signed node certificate. 
* `-extfile server.ext.tmp`: tells `openssl` to read the extensions  file created in step 9. 
--
+
The file generated by this command, `couchbase.default.svc.pem`, is the node's certificate.
+
The output of running the previous command looks like this:
+
[source, console]
----
Signature ok
subject=/CN=Couchbase Server
Getting CA Private Key
----

. Before you can deploy the key private key and the certificate to the node, you must rename their files.
Couchbase Server requires that these files have specific filenames.
Rename the certificate file to `chain.pem` and the private key file to `pkey.key`:
+
[source, console]
----
cd ./public
mv couchbase.default.svc.pem chain.pem
cd ../private
mv couchbase.default.svc.key pkey.key
----
+
NOTE: In this example you could just have `openssl` output the correct filenames in steps 5 and 9.
In production, you often create certificates for multiple nodes at the same time, and so need to give each file a unique name.

. If the node to which you're deploying the certificate does not have an inbox directory, create it. 
The inbox directory is where Couchbase Server looks for certificate, key and related files.
See xref:rest-api:load-trusted-cas.adoc[] for a list of the inbox paths on all platforms.
On Linux, this directory is `/opt/couchbase/var/lib/couchbase/inbox/`.
+
[source, console]
----
sudo mkdir /opt/couchbase/var/lib/couchbase/inbox/
----
. Deploy the node certificate and node private key by copying them to the `inbox` directory.
+
[source, console]
----
cd ..
sudo cp ./public/chain.pem /opt/couchbase/var/lib/couchbase/inbox/chain.pem
sudo cp ./private/pkey.key /opt/couchbase/var/lib/couchbase/inbox/pkey.key
----
+
NOTE: This example has a single node, so you created the node's certificate on the node where you'll deploy it.
Therefore, you can just copy the files into the correct directory using `cp`.
When creating certificates for multiple nodes, you must move the files to the node's filesystem to deploy them.
In this case, you can use a command such as `scp` to copy the files from the node on which you created the certificate to the node the certificate is for.
Remember to create the `inbox` directory on each node as well.

. Deploy the root certificate.
Couchbase Server expects to find the root certificate in a subdirectory named `CA` in the `inbox` directory.
Create the subdirectory and then copy the root CA file:
+
[source, console]
----
sudo mkdir /opt/couchbase/var/lib/couchbase/inbox/CA
sudo cp ./ca.pem /opt/couchbase/var/lib/couchbase/inbox/CA/.
----

. Make all files in the `inbox` directory readable by just the `couchbase` user:
+
[source, console]
----
sudo chown -R couchbase /opt/couchbase/var/lib/couchbase/inbox/*
sudo chmod -R 0600 /opt/couchbase/var/lib/couchbase/inbox/*
----

. Call the REST API to have Couchbase Server load the root certificate for the cluster:
+
[source, console]
----
curl -X POST http://10.143.192.102:8091/node/controller/loadTrustedCAs -u Administrator:password
----
+
. Optionally, verify that Couchbase Server has added the new root CA to its trust store: 
+
--
.. Sign into the Couchbase Server Web Console as a Full Administrator. 
.. Click menu:Security[], and click menu:Certificates[]
--
+
[#see-root-certificate-with-couchbase-web-console]
In this example, you can see both the original automatically generated root certificate and the newly uploaded certificate.  
The original generated root certificate appears at the top.
+
image::manage-security/rootCertificateWithSignedCert.png[600,align=left]
+
NOTE: You cannot delete a certificate if it has signed one or more node certificates that are in use in the cluster.
If you have multiple nodes in your cluster, you will not be able to delete the old autogenerate certificate until you have deployed node certificates signed by the new root CA.
+
For more information about the *Certificates* tab on the *Security* screen, see xref:manage:manage-security/manage-security-settings.adoc#root-certificate-security-screen-display[Certificates].

. Load the node certificate and its private key by calling the xref:rest-api:upload-retrieve-node-cert.adoc[reloadCertificate] REST API:
+
[source, console]
----
curl -X POST http://10.143.192.102:8091/node/controller/reloadCertificate -u Administrator:password
----
+
The node certificate is now activated for the current node, bearing the authority of the root CA.

For more information using the REST API to manage certificates, see xref:rest-api:rest-certificate-management.adoc[Certificate Management API].
This includes details on retrieving root and nodes certificates that have been uploaded, and on certificate deletion.

This example demonstrated configuring certificates for a single node database.
To deploy certificates for a multi-node cluster, repeat steps 6, 7, 9, 10, 11, 12, 15, and 18 for each node. 
Remember that you must copy the node's certificate and key files to its own `inbox` directory to deploy them.

[#root-intermediate-and-node-certificates]
== Create and Use Intermediate Certificates to Sign Node Certificates 

The previous example directly signed node certificates using the cluster certificate.
In some cases, you may want to use an intermediate certificate to sign the certificates for the nodes.
The primary reason to use an intermediate certificate is to prevent exposing the cluster's private key.

For example, you may want to delegate the signing of node certificates.
By creating an intermediate certificate, you can keep the cluster's private key secret while allowing others to sign node certificates.
The administrators to whom you delegate the signing of node certificates can use the intermediate certificate for signing.
They do not need use to the cluster's private key to sign the node certificates. 

For more information, see xref:learn:security/using-multiple-cas.adoc#adding-intermediate-certificates-to-the-trust-store[Adding Intermediate Certificates to the Trust Store].

When a client attempts to connect to the database securely, it uses the node's certificate to verify the node's identity.
For it to verify the node identity, the client searches for a CA it trusts in the chain of certificates from the node, through any intermediates, to the cluster certificate.
See xref:learn:security/certificates.adoc#intermediate-certificates[Intermediate Certificates] for more information.

In Couchbase Server Version 7.1 and later, you can supply the client with the chain of trust it requires in one of two ways:

* Concatenation of all intermediate and node certificates into a single `chain.pem` file, which you deploy to tne node.
The node provides this entire chain of trust to the client when it tries to connect securely.

* Deploy a `chain.pem` file containing just the node's certificate. 
In this case, the client's trust store must already have all intermediate certificates that it needs to verify the node's identity.

The following examples demonstrate both of these methods.
They assume that you have already completed the steps in xref:#root-and-node-certificates[Create and Deploy Cluster and Node Certificates].

[#intermediate-concatenation]
=== Deploy an Intermediate Certificate as Part of the Node's Trust Chain

This example demonstrates creating root, node, intermediate, and client certificates. 
It Concatenates these certificates together so the node can provide the client a complete chain of trust.

. Open a command line shell on the node for which you want to create a certificate signed by an intermediate certificate. 

. In some directory, such as your home directory or `/tmp`, create working directories:
+
[source, console]
----
mkdir servercertfiles2
cd servercertfiles2
mkdir -p {root,servers,clients}/{issued,reqs,private}
----
+
You'll use the `root`, `servers`, and `clients` directories to contain the certificates, requests, and private keys for the root, node, and client certificates.
The `issued`, `reqs`, and `private` subdirectories in these directories will contain the final certificates, the signing requests, and the private keys respectively.
+
NOTE: The example xref:manage:manage-security/configure-client-certificates.adoc#client-certificate-authorized-by-an-intermediate-certificate[Client Access: Intermediate Certificate Authorization] uses this directory structure.
It demonstrates creating the certificates that the clients need. 

. Change to the `root` directory and create a configuration file for the root certificate:
+
[source, console]
----
cd root

cat > config <<EOF
[req]
distinguished_name = cn_only
x509_extensions = ca_ext
[ cn_only ]
commonName = Common Name (eg: your user, host, or server name)
commonName_max = 64
commonName_default = CA
[ca_ext]
basicConstraints = CA:TRUE
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid:always,issuer:always
keyUsage = cRLSign, keyCertSign
EOF
----
+
The `config` file has three sections:
+
* `[req]` specifies  the values to pass to the `req` command.
This command creates and processes certificate requests.
To learn more about it and its arguments, use the command `man req`.
* `[cn_only]` provides specifications for the Common Name to used in the certificate, including the maximum number of characters and the default name.
* `[ca_ext]` provides basic extensions that limit the capability of the certificate.
Some of the settings in this section are:
** `basicConstraints  CA:TRUE` makes the certificate capable of signing other certificates.
** `keyUsage = cRLSign, keyCertSign` has two effect. 
The `cRLSign` value prevents the certificate's public key from being able to verify signatures on Certificate Revocation Lists.
And `keyCertSign` makes the certificate's public key able to verify signatures on other certificates.

. Create the root certificate, passing in the `config` file you just created:
+
[source, console]
----
openssl req -config config -new -x509 -days 3650 -sha256 -newkey rsa:2048 \
    -keyout ca.key -out ca.pem -subj '/C=UA/O=MyCompany/CN=RootCA'
----
+
This command creates both the root certificate for the cluster in a file named `ca.pem` file, and the private key in a file named `ca.key`.
The `-keyout` argument tells `openssl` to password protect the private key.
When executing the command, `openssl` prompts you for a pass phrase:
+
[source, console]
----
Generating a 2048 bit RSA private key
....+++
...................+++
writing new private key to 'ca.key'
Enter PEM pass phrase:
----
+
Anyone trying to use the certificate's private key must enter this passphrase.

. Create an extensions file to limit the capabilities of the intermediate certificate that you create in the next step:
[#create-intermediate-extensions-file]
+
[source, console]
----
cat > int.ext <<EOF
basicConstraints = CA:TRUE
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid:always,issuer:always
keyUsage = cRLSign, keyCertSign
EOF
----
+
As with the cluster certificate configuration, this configuration's `basicConstraints` setting allows the intermediate certificate to sign other certificates.
Its `keyUsage` setting also allows the certificate's public key to verify its signature on other certificates.

. Create a private key and a corresponding certificate signing request for the intermediate certificate:
+
[source, console]
----
openssl req -new -sha256 -newkey rsa:2048 -keyout ../servers/int.key \
    -out reqs/server-signing.csr \
    -subj '/C=UA/O=MyCompany/OU=Servers/CN=ServerSigningCA'
----
+
Again, the command requires `openssl` to password protect the private key, so it prompts you twice for a pass phrase.
+
The command outputs the encrypted private key in `servers/int.key` and a signing request in `root/req/server-signing.csr`.

. Create the intermediate certificate signed by the root certificate `ca.pem` and its key `ca.key`, to establish the intermediate certificate's authority:
+
[source, console]
----
openssl x509 -CA ca.pem -CAkey ca.key -CAcreateserial \
    -CAserial serial.srl -days 3650 -req -in reqs/server-signing.csr \
    -out issued/server-signing.pem -extfile int.ext
----
+
`openssl` prompts you for the pass phrase for the `ca.key` private key because you password-protected it in an earlier step. 
The command saves the intermediate certificate as `issued/server-signing.pem`.

. Make a copy of the intermediate certificate to use as the authority for the node certificates that you create in later steps.
+
[source, console]
----
cp issued/server-signing.pem ../servers/int.pem
----

. Within the `../servers` directory, create an extension file containing the information that's common across all nodes in the cluster.
+
[source, console]
----
cd ../servers

cat > server.ext <<EOF
basicConstraints = CA:FALSE
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer:always
extendedKeyUsage = serverAuth
keyUsage = digitalSignature,keyEncipherment
EOF
----
+
Some of the important values in this extension file are:
+
* `extendedKeyUsage = serverAuth` limits the purpose of the certificate to server authentication.
* `keyUsage` value `digitalSignature` specifies that the certificate's public key can be used in the verifying of information-origin.
The `keyEncipherment` value allows the public key to encrypt symmetric keys.

. Generate the private key for the node.
+
[source, console]
----
openssl genrsa -out private/couchbase.node.svc.key 2048
----

. Generate a certificate signing request for the node's certificate.
+
[source, console]
----
openssl req -new -key private/couchbase.node.svc.key \
    -out reqs/couchbase.node.svc.csr \
    -subj "/C=UA/O=MyCompany/OU=Servers/CN=couchbase.node.svc"
----

. Create a copy of the file containing the certificate extensions and append a setting specific to the node. 
+
[source, console]
----
cp server.ext temp.ext

echo 'subjectAltName = IP:10.143.192.102' >> temp.ext
----
+
The newly created `temp.ext` file adds the node's IP address as a Subject Alternative Name to the certificate. 
In Couchbase Enterprise Server Version 7.2 and later, you must add a Subject Alternative Name to the certifcate which indentifies the node.
If the certificate's Subject Alternative Name does not match the node's identity in the cluster, Couchbase Server returns an error if you try to load the certificate.
For information and options, see xref:learn:security/certificates.adoc#server-certificate-validation[Server Certificate Validation].

. Create the node certificate for the node by signing the certification request you just created using the intermediate certificate:
+
[source, console]
----
openssl x509 -CA int.pem -CAkey int.key -CAcreateserial \
    -CAserial serial.srl -days 365 -req -in reqs/couchbase.node.svc.csr \
    -out issued/couchbase.node.svc.pem -extfile temp.ext
----
+
Because you're using the intermediate certificate in this signing request, `openssl` prompts you to enter the pass phrase for the intermediate certificate's private key.
+
The command creates the node's certificate as the file `issued/couchbase.node.svc.pem`

. [[check-validity]]Check that the node certificate is valid.
The following use of the `openssl` command verifies the relationship between the root certificate, the intermediate certificate, and the node certificate.
+
[source, console]
----
openssl verify -trusted ../root/ca.pem -untrusted int.pem \
    issued/couchbase.node.svc.pem
----
+
The command outputs the following if the certificate passes the validity check:
+
----
issued/couchbase.node.svc.pem: OK
----

. Prepare the node's certificate for upload by creating the `chain.pem` certificate file.
You create `chain.pem` by concatenating the node certificate and the intermediate certificate to establish the chain of authority.
Couchbase Server expects the node's certificate file to be named `chain.pem`.
+
[source, console]
----
cat issued/couchbase.node.svc.pem int.pem > chain.pem
----

. Create a copy of the node's private key named `pkey.key` for deployment to the node.
Couchbase Server expects the node's private key to have this filename.
+
[source, console]
----
cp private/couchbase.node.svc.key pkey.key
----

. Move the node certificate and node private key into the `inbox` directory for the current node.
+
[source, console]
----
sudo mkdir /opt/couchbase/var/lib/couchbase/inbox/  

sudo cp ./chain.pem /opt/couchbase/var/lib/couchbase/inbox/chain.pem
sudo cp ./pkey.key /opt/couchbase/var/lib/couchbase/inbox/pkey.key
----

. Move the root certificate into the `inbox/CA` directory for the current node.
+
[source, console]
----
sudo mkdir /opt/couchbase/var/lib/couchbase/inbox/CA/  
cd ../root
sudo cp ca.pem /opt/couchbase/var/lib/couchbase/inbox/CA/.
----

. Make all certificate and private key files in the `inbox` readable by the `couchbase` user.
+
[source, console]
----
sudo chown -R couchbase /opt/couchbase/var/lib/couchbase/inbox/*
sudo chmod -R 0600 /opt/couchbase/var/lib/couchbase/inbox/*
----

. Upload the root certificate, activating it for the entire cluster.
+
[source, console]
----
curl -X POST http://10.143.192.102:8091/node/controller/loadTrustedCAs \
     -u Administrator:password
----

. Upload the node certificate, specifying the established password for the private key.
+
[source, console]
----
curl -X POST http://10.143.192.102:8091/node/controller/reloadCertificate \
    -u Administrator:password
----

For more information using the REST API to manage certificates, see xref:rest-api:rest-certificate-management.adoc[Certificate Management API].

[#intermediate-upload]
=== Deploy an Intermediate Certificate via Client Trust Store

The following example creates an intermediate certificate but does not concatenate it with the node's certificate. 
After following these steps, you must make sure the client's certificate contains a chain of trust it can use to verify the node's identity. 

. Perform all steps listed in the section xref:manage:manage-security/configure-server-certificates.adoc#intermediate-concatenation[Deploy an Intermediate Certificate as Part of the Node's Chain] up to and including step #14, xref:#check-validity[Check that the node certificate is valid].

. Prepare to deploy the certificate and private key for the node, by renaming both:
+
----
cp issued/couchbase.node.svc.pem chain.pem

cp private/couchbase.node.svc.key pkey.key
----

. Move the renamed node certificate and private key into the `inbox` for the current node.
+
----
sudo mkdir /opt/couchbase/var/lib/couchbase/inbox/ 

sudo cp ./chain.pem /opt/couchbase/var/lib/couchbase/inbox/chain.pem
sudo cp ./pkey.key /opt/couchbase/var/lib/couchbase/inbox/pkey.key
----

. Move the root certificate and the intermediate certificate into the `inbox/CA` directory for the current node.
+
----
sudo mkdir /opt/couchbase/var/lib/couchbase/inbox/CA/  # if needed
sudo cp int.pem /opt/couchbase/var/lib/couchbase/inbox/CA/.
cd ../root
sudo cp ca.pem /opt/couchbase/var/lib/couchbase/inbox/CA/.
----

. Make sure that all certificate and private key files in the `inbox` directory can be read by user `couchbase`.
+
[source, console]
----
sudo chown -R couchbase /opt/couchbase/var/lib/couchbase/inbox/*
sudo chmod -R 0600 /opt/couchbase/var/lib/couchbase/inbox/*
----

. Upload the root and intermediate certificates.
+
----
curl -X POST http://10.143.192.102:8091/node/controller/loadTrustedCAs \
     -u Administrator:password
----

. Upload the node certificate, specifying the established password for the private key.
+
----
curl -X POST http://10.143.192.102:8091/node/controller/reloadCertificate 
     -u Administrator:password
----
+
NOTE: When the cluster contains more than one node, you must repeat the call to `/node/controller/reloadCertificate` for each node.
Be sure to use the IP address of each node in the POST URL to have each node reload its certificates.
Also, copy the files to the node's inbox on its own filesystem.
The files must be on the node for the REST API call to work.

The node's certificate is now deployed.
The node's certificate does not contain a chain of trust that includes the intermediate certificate.
You must make sure each client certificate does have a copy. 

For more information using the REST API to manage certificates, see xref:rest-api:rest-certificate-management.adoc[Certificate Management API].


== Single Versus Multiple Root Certificates:

The examples in this page show using a single root certificate for the cluster.
Couchbase Server prior to version 7.1, supported using just single root certificate.
Couchbase Server 7.1 and later supports using multiple root certificates in a trust store for the cluster.
xref:learn:security/using-multiple-cas.adoc[Using Multiple Root Certificates] explains how these multiple certificates work in Couchbase Server.

Procedures for creating root certificates, and using these to sign node or intermediate certificates, do not change when you use multiple root certificates.

== Encrypted Node Private Keys

The some of the examples use an encrypt private key for the node.
You must register the passphrase so that the key can be securely retrieved and used when required.
See  xref:rest-api/upload-retrieve-node-cert.adoc[Upload and Retrieve a Node Certificate] for details.

[#configure-client-access-advanced]
== Configuring Client Access

Once you have configured root, intermediate, and node certificates for the cluster, you can create client certificates so clients can securely connect. 
You can choose to create an intermediate client certificate that itself inherits the authority of the root.
Client-certificate preparation varies, depending on the type of client.
For steps to prepare a client certificate to support connections between Couchbase Server databases, see xref:manage:manage-security/configure-client-certificates.adoc#client-certificate-authorized-by-an-intermediate-certificate[Client Access: Intermediate-Certificate Authorization].
For steps to prepare a certificate for a Java client, see xref:manage:manage-security/configure-client-certificates.adoc#java-client-access-intermediate-certificate-authorization[Java Client Access: Intermediate-Certificate Authorization].

NOTE: Client connections secured by client certificate must be enabled on the cluster.
See xref:manage:manage-security/enable-client-certificate-handling.adoc[Enable Client-Certificate Handling].

[#using-an-externally-provided-root-certificate]
== Using an Externally Provided Root Certificate

The examples in this page create a self-signed root certificate use that certificate's private key to sign other certificates.
In production environments, you often want to use a root certificate signed by a well-known Certificate Authority.
In this case, instead of creating the cluster certificate yourself, you will use the certificate signed by the external CA to sign certificates.
You also usually create intermediate certificates to sign the node and client certificates instead of directly signing them using the cluster certificate.


[#adding-new-nodes]
== Adding and Joining New Nodes

When a cluster uses the default auto-generated certificates, you do not need to generate a new certificate for new nodes.
Once you configure the cluster to use custom certificates, you must generate a new certificate when adding or joining new nodes to the cluster.
In Couchbase Server Version 7.1 always adds or joins new nodes  over an encrypted connection.

When a cluster using custom certificates adds or joins a new node to itself, the new node must interact with an existing node.
This interaction requires both the existing node and the new node to verify each other's identity using their chains of trust.
Therefore, certificates of the existing and new node must have a common CA in their trust chain.
In most cases, you make sure the nodes can identify  each other by signing them with the cluster certificate or the same intermediate certificate.
If, for some reason, you cannot use the same certificate to sign the node's certificates, you must concatenate the intermediate certificates to each node's certificate.
This concatenation make sure the nodes can find a common CA in their chain of trust to identify each other.

[#readding-a-previously-removed-node]
=== Re-Adding Node

When you remove a node from a cluster, Couchbase Server deletes its configuration including its certificates chains.
If you add the removed node back to the cluster, Couchbase Server adds it as a new node with a new configuration.
Therefore, you must make sure node has the the appropriate root certificate and chain certificate.

For more information about removing  nodes, see xref:learn:clusters-and-availability/removal.adoc[Removal].

[#regenerating-default-certificates]
== Regenerating Default Certificates

When it creates the cluster, Couchbase Server generates default certificates for the cluster and initial node.
It also generates certificates for additional nodes you add later.
You can have Couchbase Server regenerate the certificates using a the REST API call. 
This call has Couchbase Server generate a new self-signed root certificate and add it to its trust store.
It then creates new node certificates signed by the new root certificate, overwriting existing node certificates.
Any old auto-generated and custom root certificates remain in the cluster's trust store.

For information about regenerating certificates, see xref:rest-api:rest-regenerate-all-certs.adoc[Regenerate All Certificates].
For information about deleting root certificates, see xref:rest-api:delete-trusted-cas.adoc[Delete Root Certificates].

[#further-information]
== Further Information

For information about certificate-management using the REST API, see xref:cli:cbcli/couchbase-cli-ssl-manage.adoc[ssl-manage] and xref:rest-api:rest-certificate-management.adoc[Certificate Management API].

For step-by-step instructions on creating client certificates, see xref:manage:manage-security/configure-client-certificates.adoc[Configure Client Certificates].

For an example of using node and  xref:manage:manage-security/configure-client-certificates.adoc[client certificates] to secure XDCR replication between clusters, see xref:manage:manage-xdcr/enable-full-secure-replication.adoc#specify-full-xdcr-security-with-certificates[Specify Root and Client Certificates, and Client Private Key].
