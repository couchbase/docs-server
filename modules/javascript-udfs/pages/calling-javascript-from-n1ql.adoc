= Calling JavaScript User-Defined Functions from N1QL
:description: Using a N1QL Reference Function to call JavaScript UDFs.
:page-pagination: 
:page-edition: Enterprise Edition
:page-toclevels: 2

[abstract]
{description}

== Introduction

Before you can call a JavaScript User-Defined Function, you must first create a N1QL reference function register the UDF.
The process to do this is explained in the  xref:guides:creating-javascript-library.adoc#creating-the-reference-function[Creating the Reference Function] section of our xref:guides:javascript-udfs.adoc[] guide.

If you are unfamiliar with JavaScript User-Defined Functions in JavaScript, then the xref:guides:javascript-udfs.adoc[guide] is the best place to start.

In this section, we're going to take a closer look at reference functions, such as variadic parameter list.

== UDFs and Reference Functions

A JavaScript User-Defined Function can be xref:guides:creating-javascript-library.adoc#creating-the-library-and-adding-your-first-function[created through the WorkBench or through the REST API]. 

[source, javascript, role="no-callouts"]
----
include::example$get-business-days.js[]
----

And the corresponding reference function can be created through the xref:guides:creating-javascript-library.adoc#creating-the-reference-function[Query Workbench] or by executing a N1QL statement:

[source, n1ql]
----
include::example$create-scoped-reference-function.n1ql[] 
----
<.> The new reference function is called `GetBusinessDays` and takes the `inventory` scope inside the `travel-sample` bucket.
As well as providing a logical separation between JavaScript libraries, using scopes provides a means of securing access to the library: a user must have a context that matches the scope of the library in order to access it.
<.> This function will reference the `getBusinessDays` function
<.> which is in a library called `my-library` which is set to the `inventory` scope within the `travel-sample` bucket.


.The Global scope
[sidebar]
****
Of course, you can define the library and reference function with a `global` scope by defining them without the scope parameters. 
Functions with a global scope are accessible across the cluster.

.Creating a reference function with a global scope
[source, n1ql]
----
include::example$create-globally-scoped-reference-function.n1ql[]
----
****

== Calling the Function

Once the reference function is defined, it can be called as if it were a built-in N1QL function:

.Query
[source, n1ql]
----
include::example$select-get-business-days.n1ql[]
---- 

which will return the following result:

.Result
[source, json]
----
include::example$select-get-business-days-response.jsonc[]
----

You can also use the `EXECUTE FUNCTION` statement to execute the function:

[source, n1ql]
----
include::example$execute-javascript-function.n1ql[]
----

or as part of a complex statement:

[source, n1ql, role=no-callouts]
----
include::example$select-true-alias-get-business-days.n1ql[]
----

== Variadic Parameters

You can define a reference function with a variadic parameter, which means that the parameter will accept a list of values which it will pass to the UDF function it references.


include::partial$wip.adoc[]

