= Calling JavaScript UDFs from N1QL
:description: Using a N1QL Reference Function to call JavaScript UDFs.
:page-edition: Enterprise Edition
:page-toclevels: 2

[abstract]
{description}

== Introduction

Before you can call a JavaScript User-Defined Function, you must first create a N1QL reference function register the UDF.
The process to do this is explained in the  xref:guides:creating-javascript-library.adoc#creating-the-reference-function[Creating the Reference Function] section of our xref:guides:javascript-udfs.adoc[] guide.

If you are unfamiliar with JavaScript User-Defined Functions in JavaScript, then the xref:guides:javascript-udfs.adoc[guide] is the best place to start.

In this section, we're going to take a closer look at reference functions, such as variadic parameter list.

== UDFs and Reference Functions

A JavaScript User-Defined Function can be xref:guides:creating-javascript-library.adoc#creating-the-library-and-adding-your-first-function[created through the WorkBench or through the REST API]. 

[source, javascript, role="no-callouts"]
----
include::example$get-business-days.js[]
----

And the corresponding reference function can be created through the xref:guides:creating-javascript-library.adoc#creating-the-reference-function[Query Workbench] or by executing a N1QL statement:

[source, n1ql]
----
include::example$create-scoped-reference-function.n1ql[] 
----
<.> The new reference function is called `GetBusinessDays` and takes the `inventory` scope inside the `travel-sample` bucket.
As well as providing a logical separation between JavaScript libraries, using scopes provides a means of securing access to the library: a user must have a context that matches the scope of the library in order to access it.
<.> This function will reference the `getBusinessDays` function
<.> which is in a library called `my-library` which is set to the `inventory` scope within the `travel-sample` bucket.


.The Global scope
[sidebar]
****
Of course, you can define the library and reference function with a `global` scope by defining them without the scope parameters. 
Functions with a global scope are accessible across the cluster.

.Creating a reference function with a global scope
[source, n1ql]
----
include::example$create-globally-scoped-reference-function.n1ql[]
----
****

== Calling the Function

Once the reference function is defined, it can be called as if it were a built-in N1QL function:

.Query
[source, n1ql]
----
include::example$select-get-business-days.n1ql[]
---- 

which will return the following result:

.Result
[source, json]
----
include::example$select-get-business-days-response.jsonc[]
----

You can also use the `EXECUTE FUNCTION` statement to execute the function:

[source, n1ql]
----
include::example$execute-javascript-function.n1ql[]
----

or as part of a complex statement:

[source, n1ql, role=no-callouts]
----
include::example$select-true-alias-get-business-days.n1ql[]
----

[#variadic-parameters]
== Variadic Parameters

You can define a reference function with a variadic parameter, which means that the parameter will accept a list of values which it will pass to the UDF function it references.
We can create the `GetBusinessDays` function using a variadic parameter rather than the `startDate` and `endDate` parameters:

[source, n1ql]
----
include::example$create-variadic-reference-function.n1ql[]
----
Note that the statement used three dots (...) rather than a list of parameter list. This indicates a variable length parameter list. 
The underlying JavaScript function will reference the parameter list as named variables:

[source, javascript, role=no-callouts]
----
include::example$get-business-days-no-ops.js[]
----

Alternatively, you can use a variable length parameter list in the JavaScript function itself:

[source, javascript]
----
include::example$variadic-sum.js[]
----
<.> JavaScript uses three dots (...) followed by a parameter name to denote a parameter that is an array of values.
<.> Scans through the variadic parameter list, summing all the numbers it contains.

A reference function can now be created that takes a variable length list of numbers as an argument:

[source, n1ql]
----
include::example$create-sum-function.n1ql[]
----

which can then be called with a variable length list of numbers as a parameter

.Query
[source, n1ql]
----
include::example$execute-sum-function.n1ql[]
----

.Result
[source, json]
----
include::example$execute-sum-function-result.jsonc[]
----
