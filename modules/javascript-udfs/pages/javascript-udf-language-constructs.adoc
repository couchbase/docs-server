= JavaScript User-Defined Functions
:description: Writing Couchbase Server extension functions in the JavaScript Language.
:page-edition: Enterprise Edition
:page-toclevels: 2
:page-pagination: next

[abstract]
{description}

== Introduction

Using JavaScript, you can write your custom Functions.
Couchbase Functions inherit support for most ECMAScript constructs by using Google v8 as the execution container.
However, to support the ability to shard and scale Function-execution automatically, some capabilities have been removed.
Additionally, to optimize language-utilization of the server environment, some new constructs have been added.


[#added-lang-features]
== Added Language Features

The following constructs have been added:

* N1QL Statements
*  Basic Keyspace Accessors
*  Advanced Keyspace Accessors

Details on xref:eventing:eventing-language-constructs.adoc#bucket_accessors[Basic Keyspace Accessors] and xref:eventing:eventing-language-constructs.adoc#advanced_bucket_accessors[Advanced Keyspace Accessors] can be found in xref:eventing:eventing-language-constructs.adoc[].

=== N1QL Statements

Top level N1QL keywords, such as SELECT, UPDATE, INSERT and DELETE, are available as inline keywords in JavaScript functions. Operations that return values such as SELECT are accessible through a returned iterable handle. N1QL Query results, via a SELECT, are streamed in batches to the iterable handle as the iteration progresses through the result set.

NOTE: N1QL DML statements cannot manipulate documents in the same bucket as the function is listening for mutations on to avoid recursion. Workaround: use the exposed data service KV map in your function.

JavaScript variables can be referred by N1QL statements using *$<variable>* syntax. Such parameters will be substituted with the corresponding JavaScript variable's runtime value using N1QL named parameters substitution facility.

When deploying the below Function with a feed boundary of "Everything" the same N1QL statement will execute 7,303 times. If the feed boundary is configured to "From now", and you then mutate just one (1) document in the keyspace `beer-sample`.`_default`.`_default` only one (1) query will be executed.  Also keep in mind that adding an optimal index can speed up the query performance by 24X.

[source,javascript]
----
function OnUpdate(doc, meta) {
    var strong = 70;
    var results =
        SELECT *                               /* N1QL queries are embedded directly.    */
        FROM `beer-sample`._default._default   /* Token escaping is standard N1QL style. */
        WHERE abv > $strong;                   // Local variable reference using $ syntax.
    for (var beer of results) {                // Stream results using 'for' iterator.
        log(beer);
        break;
    }
    results.close();                           // End the query and free resources held
}
----

The embedded N1QL call starts the query and returns a JavaScript Iterable object representing the result set of the query. The query is streamed in batches as the iteration proceeds. The returned handle can be iterated using any standard JavaScript mechanism including _for...of_ loops.

In multiline N1QL statements (as above) you cannot use single line [.var]`// end of line comments like this` +
prior to the terminating semicolon as it will cause a syntax error in the transpilation of the N1QL statement, however multiline [.var]`/* comments like this */` are allowed.

The iterator is an input iterator (elements are read-only). The keyword _this_ cannot be used in the body of the iterator. The variables created inside the iterator are local to the iterator.

The returned handle must be closed using the [.var]`close()` method defined on it, which stops the underlying N1QL query and releases associated resources.

NOTE: When a function completes for a given mutation and exits all resources will be freed even if you omit the [.var]`close()` statement for your result set(s). However, in some complex use cases such as nested N1QL lookups a failure to explicitly call [.var]`close()` after each result set is no longer needed can tie up an excessive amount of N1QL resources and lead to poor performance.

All three operations, i.e., the N1QL statement, iterating over the result set, and closing the Iterable handle can throw exceptions if unexpected error arises from the underlying N1QL query.

As N1QL is not syntactically part of the JavaScript language, the function code is transpiled to identify valid N1QL statements which are then converted to a standard JavaScript function call that returns an Iterable object with addition of a [.var]`close()` method.

You must use [.var]`$<variable>`, as per N1QL specification, to use a JavaScript variable in the query statement.
The object expressions for substitution are not supported and therefore you cannot use the [.param]`meta.id` expression in the query statement.

Instead of [.param]`meta.id` expression, you can use `var id = meta.id` in an N1QL query.

* Invalid N1QL Statement
+
[source, N1QL]
----
DELETE FROM mybucket.myscope.transactions WHERE username = $meta.id;
----

* Valid N1QL Statement
+
[source, N1QL]
----
var id = meta.id;
DELETE FROM mybucket.myscope.transactions WHERE username = $id;
----
 
When you use a N1QL query inside a function, remember to use an escaped identifier for keyspaces (bucket.scope.collection) with special characters
(+++`+++[.param]`bucket-name`+++`+++).
Escaped identifiers are surrounded by back ticks and support all identifiers in JSON

For example:

* If the bucket name is [.param]`beer-sample` and the scope and collection are both _default, then only the bucket in the N1QL needs to be escaped:
+
[source, N1QL]
----
SELECT * FROM `beer-sample`._default._default WHERE type ...
----

* However, if the bucket name was [.param]`beersample`, then the keyspace of the N1QL query needs no escaping:
+
[source, N1QL]
----
SELECT * FROM beersample._default._default WHERE type ...
----

[#build-in-functions]
== Built-in Functions

The following built in functions have been added:

* xref:built-in-functions.adoc#n1ql-function[N1QL() Function Call]
* xref:built-in-functions.adoc#crc64-function-call[crc64() Function Call]
* xref:built-in-functions.adoc#create-timer-cancel-timer[createTimer() and cancelTimer() Functions]

[#handler-signatures]
== Handler Signatures

The Eventing Service calls the following entry points or JavaScript functions on events (mutations or fired timers).

* OnUpdate Handler
* OnDelete Handler
* Timer Callback Handler

The Eventing Service calls are covered in xref:eventing:eventing-language-constructs.adoc#handler-signatures[Eventing: handler signatures].

[#removed-lang-features]
== Removed Language Features

The following JavaScript features have been removed and cannot be used in functions:

* <<global_state,Global State>>
* <<asynchronicity,Asynchronicity>>
* <<browser_extensions,Browser and other Extensions>>

[#global_state]
=== Global State

Functions do not allow global variables. All state must be saved and retrieved from persistence providers. In Couchbase Server, the Data Service provider is used as a persistence provider. Therefore, all global states are contained in the Data Service bucket(s) made available to the Eventing Functions through bindings. This restriction is mandatory for the logic to remain agnostic of the rebalance operation.

[source,javascript]
----
var count = 0;                         // Not allowed - global variable.
function OnUpdate(doc, meta) {
  count++;
}
----

Note the use of 'Constant alias' bindings in the Function's settings can be used to provide global constants accessible within a Function's JavaScript.  For example you might have a Constant alias of _debug_ with a value of _true_ (or _false_) to control verbose logging this would behaves just like adding a statement `const debug = true;` at the beginning of your JavaScript code.

[#asynchronicity]
=== Asynchronicity

For asynchronicity, particularly asynchronous callbacks, to be useful, functions need to retain access to their parent scope. As such asynchronicity forms a node specific, long-running state that prevents the capture of the entire state in the persistence providers. Therefore, functions are restricted to executing as short-running, straight-line code, without sleep and wakeups. 

[source,javascript]
----
function OnUpdate(doc, meta) {
  setTimeout(function(){}, 300);     // Not allowed - asynchronous flow.
}
----

Limited asynchronicity is added back through time observers (or Timers). Time observers are designed specifically not to make the state node specific.

[#browser_extensions]
=== Browser and other Extensions

Functions execute as server-side code on Couchbase Server similar to the JavaScript code that is used in browsers.

Because functions do not execute in the context of a browser, the extensions that browsers add to the core language, such as window methods, DOM events etc. are not available. The Couchbase Server prevents these browser extensions from executing in a function.  However a limited subset is added back (such as function timers in lieu of setTimeout, and curl calls in lieu of XHR).

For example some code that runs in the browser is excluded from use in functions. The ‘window’ term in the code *window.XMLHttpRequest()*, is not a server-side construct but is in the context of a browser and as such is not available to your functions.

[source,javascript]
----
function OnUpdate(doc, meta) {
  var rpc = window.XMLHttpRequest();  // Not allowed - browser extension.
}
----

== Reserved Words

Reserved words are words that cannot be used in JavaScript as a variable name or function name, or as a property. T
he following table lists the reserved words that you must refrain from using as they are used by the transpiler to integrate with Couchbase's query language, N1QL.

|===
4+| N1QL Keywords

| ALTER
| EXECUTE
| MERGE
| UPDATE

| BUILD
| EXPLAIN
| PREPARE
| UPSERT

| CREATE
| GRANT
| RENAME
|

| DELETE
| INFER
| REVOKE
|

| DROP
| INSERT
| SELECT
|
|===

[discrete]
=== What Happens If You Use a Reserved Word?

Let's say you try to create a new function with JavaScript code using a reserved word for variable names, for function names, and as a property binding value. All three cases generate a deployment error.

Reserved words as a variable name:

[source,javascript]
----
function get_numip_first_3_octets(ip) {
    var grant = 0;
    if (ip) {
        var parts = ip.split('.');
    }
}
----

Reserved words as a function name:

[source,javascript]
----
function grant(ip) {
    var return_val = 0;
    if (ip) {
        var parts = ip.split('.');
    }
}
----

During the Function deployment step, when the system validates the function's JavaScript code, it displays an error message such as the following:

[source, console, subs="quotes"]
----
Deployment failed: Syntax error *[line and column numbers]* - grant is a reserved name in N1QLJs`
----


Reserved words as a property bindings value

image::reserved-words-7_0.png[,642]

