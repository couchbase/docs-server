= Built-In Functions
:description: A library of JavaScript functions for use with the CouchBase Server
:page-pagination: prev
:page-edition: Enterprise Edition
:page-toclevels: 2

[abstract]
{description}

[#n1ql-function]
== The N1QL() Function Call

The _N1QL()_ function call  is documented below for reference purposes but should not used directly as doing so would bypass the various semantic and syntactic checks of the transpiler (notably: recursive mutation checks will no longer function, and the statement will need to manual escaping of all N1QL special sequences and keywords).

NOTE: In addition, the _N1qlQuery()_ is now deprecated and has been replaced with the _N1QL()_ call which has a different parameter format.

 *statement*:: This is the identified N1QL statement. This will be passed to N1QL via SDK to run as a prepared statement. All referenced JS variables in the statement (using the $var notation) will be treated by N1QL as named parameters.

 *params*:: This can be either a JavaScript array (for positional parameters) or a JavaScript map. When the N1QL statement utilizes positional parameters (i.e., $1, $2 ...), then params is expected to be a JavaScript array corresponding to the values to be bound to these positional parameters. When the N1QL statement utilizes named parameters (i.e., $name), then params is expected to be a JavaScript map object providing the name-value pairs corresponding to the variables used by the N1QL statement. Positional and named value parameters cannot be mixed.
+
NOTE: adding an optimal index to the `travel-sample`.`_default.`_default` keyspace for the below query can increase the performance by 57X.
+
.Iterator using a positional params array
[source,javascript]
----
    // Using `travel-sample`._default._default to demonstrate params.
    // a) Positional param 1 is field 'iata' from the input doc
    // b) Positional param 2 from an Eventing Function variable: max_dist
    // c) Will also prepare the statement for better performance
    
    if (doc.type !== "airline") return; // only process airline docs
    
    var max_dist = 120;
    var results = N1QL(
        "SELECT COUNT(*) AS cnt " +
        "FROM `travel-sample`._default._default " +
        "WHERE type = \"route\" " +
        "AND airline = $1 AND distance <= $2",
        [doc.iata,max_dist], 
        { 'isPrepared': true }
    );
----
+
.Example iterator using a named params object
[source,javascript]
----
    // Using `travel-sample`._default._default to demonstrate named params.
    // a) Named param 1 '$mytype' is a hardcode
    // b) Named param 2 '$myairline' is field 'iata' from the input doc
    // c) Named param 3 '$mydistance' if from an Eventing Function variable max_dist
    // d) Set the consistency in the options to none
    
    if (doc.type !== "airline") return; // only process airline docs
    
    var max_dist = 120;
    var results = N1QL("SELECT COUNT(*) AS cnt " +
        "FROM `travel-sample`._default._default " +
        "WHERE type = $mytype " +
        "AND airline = $myairline AND distance <= $mydistance",
        { '$mytype': 'route', '$mydistance': max_dist, '$myairline': doc.iata },         
        { 'consistency': 'none' }
    );
----
{empty}

*options*:: This is a JSON object having various query runtime options as keys. Currently, the following settings are recognized:
+
{empty}
+
*isPrepared*::: This controls if the statement will be prepared. Normally, this defaults to _false_ but can be set on a per statement basis to _true_ for any N1QL query that needs increased performance.

 *consistency*::: This controls the consistency level for the statement. Normally, this defaults to the consistency level specified in the overall Eventing Function settings but can be set on a per statement basis. The valid values are "none" and "request".

 *return value (handle)*:: The call returns a JavaScript Iterable object representing the result set of the query. The query is streamed in batches as the iteration proceeds. The returned handle can be iterated using any standard JavaScript mechanism including for...of loops.
+
{empty}
+

*close() Method on handle object (return value)*:::: This releases the resources held by the N1QL query. If the query is still streaming results, the query is cancelled.
+
{empty}
*Exceptions Thrown*:: The N1QL() function throws an exception if the underlying N1QL query fails to parse or start executing. The returned Iterable handler throws an exception if the underlying N1QL query fails after starting. The close() method on the iterable handle can throw an exception if underlying N1QL query cancellation encounters an unexpected error.

[#crc64-function-call]
== The crc64() Function Call

_crc64()_: This function calculates the CRC64 hash of an object using the ISO polynomial. The function
takes one parameter, the object to checksum, and this can be any JavaScript object that can be
encoded to JSON. The hash is returned as a string (because JavaScript numeric types offers only
53-bit precision). Note that the hash is sensitive to ordering of parameters in case of map
objects.

[source,javascript]
----
function OnUpdate(doc, meta) {
    var crc_str = crc64(doc);
    /// code here ...
}
----

The *crc64* function can be useful in cases like suppressing a duplicate mutation from the Sync Gateway (SG), when both the Sync Gateway & Eventing are leveraging the same bucket. Basically, Sync Gateway updates metadata of the document within the bucket, which in turn generates an event for Eventing to process. Eventing can't differentiate between events from Sync Gateway and other events (doc updates via SDK, N1QL, and others).  A workaround to this double mutation issue is possible via the *crc64()* function.

[source,javascript]
----
function OnUpdate(doc, meta) {
    // Ignore documents created by Sync Gateway
    if(meta.id.startsWith("_sync") == true) return;

    // Ignore documents whose body has not changed since we last saw it
    var prev_crc = checksum_bucket[meta.id];
    var curr_crc = crc64(doc);
    if (prev_crc === curr_crc) return;
    checksum_bucket[meta.id] = curr_crc;

   // Business logic goes in here
}
----
NOTE: that if multiple Eventing Functions share the same Sync Gateway crc64() checksum documents, real mutations will be suppressed and missed. In this use case make the checksum documents unique to each Eventing Function, i.e. checksum_bucket["evfunc1:" + meta.id], checksum_bucket["evfunc2:" + meta.id], etc.

[#create-timer-cancel-timer]
== The createTimer() and cancelTimer() Functions

Timers are asynchronous compute, which offers Eventing Functions the ability to execute in reference to wall-clock events, refer to the detailed xref:eventing:eventing-timers.adoc[Timers] documentation. 

[#createtimer_call]
*The createTimer() Function Call*: _createTimer(callback, date, reference, context)_

To create a timer a callback or JavaScript function will be executed at or close to the desired date. The reference is an identifier for the timer scoped to an Eventing function and callback. The context must be serializable data that is available to the callback when the timer is fired. 
For more information see xref:eventing:eventing-timers.adoc#createtimer-function[createTimer function].

[#canceltimer_call]
*The cancelTimer() Function Call*: cancelTimer(callback, reference)

To cancel a timer you can either by invoking _createTimer()_ with the same reference of an existing timer or you can use the _cancelTimer() function.
For more information see xref:eventing:eventing-timers.adoc#canceltimer-function[cancelTimer function].

