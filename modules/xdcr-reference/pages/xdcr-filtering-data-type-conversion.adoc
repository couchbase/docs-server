= XDCR Data-Type Conversion

[abstract]
_XDCR filtering expressions_ are supported by data-type _conversion_ and _collation_.

== Understanding Data-Type Conversion

_XDCR filtering expressions_ allow case-sensitive matches, comparisons, logical and other operations to be performed on values within documents.
When values referenced by a filtering expression have different data-types, either _conversion_ or _collation_ is performed:

* _Conversion_ means that one or more of the values is converted from its existing data-type to another, so that the operation is performed on values of the same data-type.

* _Collation_ means that conversion is not possible; and that therefore, the operation will be otherwise resolved, according to a set of rules.

All conversion performed by XDCR is _implicit_, meaning that it is performed automatically within the system.
No _explicit_ conversion (that is, data-type conversion selected and imposed by the administrator) is supported.

[#supported-data-types]
== Supported Data Types

The data-types supported by XDCR Filtering are listed below, in order of _precedence_.

[cols="1,4"]
|===
| *Precedence* | *Data Type*
| 0 | Invalid
| 1 | Missing
| 2 | Null
| 3 | Boolean
| 4 | Numeric
| 5 | String
| 6 | Time
| 7 | Array
| 8 | Object
| 9 | Binary
|===

When an expression entails values of the same data-type, no conversion is required.
When the data-types differ, and conversion or collation is therefore required, data-types take precedence in accordance with their closeness to the top of the list.
For example, if an operation refers to two values, one of which is _Invalid_ and the other of which is _Boolean_, the _Invalid_ value determines the result.
As another example, if an operation refers to two values, one of which is _Boolean_ and the other _Numeric_, the _Numeric_ value is if possible converted to _Boolean_, and the operation performed.

[#numeric-type-conversion]
== Numeric Data-Type Internal Conversions

A value of the _Numeric_ data type (listed above, in xref:xdcr-reference:xdcr-filtering-data-type-conversion.adoc#supported-data-types[Supported Data Types]) always further corresponds to one of three _internal_ numeric data types; which are _unsigned integer_, _integer_, and _float_.
When two _Numeric_ data-type values are referenced in a filtering expression, comparisons (_e.g._ equality, inequality) and operations (_e.g._ addition, subtraction) are performed as indicated in the following table.

[cols="3,3,7,7"]
|===
| *Type 1* | *Type 2* | *Comparison* | *Operation*

| `Uint`
| `Uint`
| The comparison is performed.
| The operation is performed.
If the operation results in a negative value, both values are converted to `Int`, and the operation is repeated; _unless_ one or both conversions to `Int` would result in overflow, in which case `InvalidValue` is returned.

| `Uint`
| `Int`
| If `Int` is negative, `Uint` is converted to `Int`, and the comparison is performed; _unless_ the conversion to `Int` would result in overflow, in which case `InvalidValue` is returned.

If `Int` is positive, `Int` is converted to `Uint`, and the comparison is performed.

| The operation is performed.
If the result is an `Int`, the `Int` is returned.
If the result is a valid `Uint`, the `Uint` is returned.
If the result is a _non-valid_ `Uint` (due to the result's being negative), the result is converted to `Int`, and is returned as such; _unless_ the conversion to `Int` would result in overflow, in which case, `InvalidValue` is returned.

| `Uint`
| `Float`
| `Uint` is converted to `Float`, and the comparison is performed.
| `Uint` is converted to `Float`, and the operation is performed.

| `Int`
| `Float`
| `Int` is converted to `Float`, and the comparison is performed.
| `Int` is converted to `Float`, and the operation is performed.

| `Float`
| `Float`
| The comparison is performed.
| The operation is performed.

| `Int`
| `Int`
| The comparison is performed.
| The operation is performed.

|===

[#implicit-conversion-vs-collation-comparison]
== Implicit Conversion versus Collation Comparison

_Implicit conversion_ occurs when Couchbase Server converts a value from its existing data-type to another, so that a comparison or operation can be performed on values of the same data type.
Implicit conversion is only _sometimes_ possible: therefore, when an existing data type _cannot_ be implicitly converted into another, _collation comparison_ is used instead.

Collation comparison works as follows:

* _Equality_ and _inequality_.
Checking for _equality_ between different data types returns `false`.
Therefore, if `var1` and `var2` represent different data types, the expression `var1 == var2` returns `false`.
+
Checking for _inequality_ between different data types returns `true`.
Therefore, if `var1` and `var2` represent different data types, the expression `var1 != var2` returns `true`.

* _Regular expression_ matches.
Checking for a regular-expression _match_ between different data types returns `false`.
Therefore, if `var1` and `var2` represent different data types, the expression `REGEXP_CONTAINS(var1, var2)` returns `false`.
+
Checking for a regular-expression _non-match_ between different data types returns `true`.
Therefore, if `var1` and `var2` represent different data types, the expression `NOT REGEXP_CONTAINS(var1, var2)` returns `true`.

* _Magnitude comparison_ between different data types is resolved in accordance with the respective positions of the data types in the list of xref:xdcr-reference:xdcr-filtering-data-type-conversion.adoc#supported-data-types[Supported Data Types]).
This list presents the supported data types in order of _precedence_: note that _precedence_ and _magnitude_ are inversely proportional; and that therefore, the data type at the bottom of the list (Binary) has the least precedence and greatest magnitude; while the data type at the top (Invalid) has the greatest precedence and least magnitude.
+
Consequently, if the data type of `var1` is _below_ that of `var2` in the list, the expression `var1 > var2` returns `true`; and the expression `var1 < var2` returns `false`.

[#supported-type-conversions]
== Supported and Unsupported Type Conversions

The following table lists supported and unsupported type conversions.

[cols="3,3,3,3,3,3,3,3,3,3,3,3"]
|===

|
| _Fr_ *Int*
| _Fr_ *Ui*
| _Fr_ *Flt*
| _Fr_ *Str*
| _Fr_ *Rgx*
| _Fr_ *Pcr*
| _Fr_ *Null*
| _Fr_ *Bl*
| _Fr_ *Ary*
| _Fr_ *Obj*
| _Fr_ *Tm*

| _To_ *Int*
|
| image:learn:introduction/yes.png[]
|
|
|
|
|
|
|
|
|

| _To_ *Ui*
|
|
|
|
|
|
|
|
|
|
|

| _To_ *Flt*
|
|
|
|
|
|
|
|
|
|
|

| _To_ *Str*
|
|
|
|
|
|
|
|
|
|
|

| _To_ *Rgx*
|
|
|
|
|
|
|
|
|
|
|

| _To_ *Pcr*
|
|
|
|
|
|
|
|
|
|
|

| _To_ *Null*
|
|
|
|
|
|
|
|
|
|
|

| _To_ *Bl*
|
|
|
|
|
|
|
|
|
|
|

| _To_ *Ary*
|
|
|
|
|
|
|
|
|
|
|

| _To_ *Obj*
|
|
|
|
|
|
|
|
|
|
|

| _To_ *Tm*
|
|
|
|
|
|
|
|
|
|
|

|===
