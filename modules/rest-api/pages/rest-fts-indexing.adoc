= Indexes

== Index Definition

[[g-api-index]]GET /api/index::
Returns all index definitions as JSON.
+
*Permission Required*: cluster.bucket[[.var]`bucket_name`].fts!read
+
*Role Required*: FTS-Admin
+
.Sample Response
----
{
    "indexDefs": {
        "implVersion": "4.0.0",
        "indexDefs": {
            "myFirstIndex": {
            "name": "myFirstIndex",
            "params": "",
            "planParams": {
                "hierarchyRules": null,
                "maxPartitionsPerPIndex": 0,
                "nodePlanParams": null,
                "numReplicas": 0,
                "planFrozen": false
             },
             "sourceName": "",
             "sourceParams": "",
             "sourceType": "nil",
             "sourceUUID": "",
             "type": "fulltext-index",
             "uuid": "6cc599ab7a85bf3b"
          }
       },
       "uuid": "6cc599ab7a85bf3b"
    },
    "status": "ok"
}
----

[[g-api-scoped-indexes]]GET /api/bucket/{$BUCKET_NAME}/scope/{$SCOPE_NAME}/index::
Returns a list of all index definitions inside the specified bucket and scope. 
+
*Permission Required*: cluster.bucket[[.var]`$BUCKET_NAME`].fts!read
+
*Role Required*: FTS-Admin
+
*Parameters*

* [.param]`{$BUCKET_NAME}`: required, string, URL path parameter
+
The name of the bucket where you want to return Search index definitions. 

* [.param]`{$SCOPE_NAME}`: required, string, URL path parameter
+
The name of the scope where you want to return Search index definitions. 
+
.Sample response
----
{
    "status": "ok",
    "indexDefs": {
        "uuid": "23cf9530131858b8",
        "indexDefs": {
            "travel-sample.inventory.travel-hotel": {
                "type": "fulltext-index",
                "name": "travel-hotel",
                "uuid": "a04a16f178846bc4",
                "sourceType": "gocbcore",
                "sourceName": "travel-sample",
                "sourceUUID": "8f866261438f8b0d415a437552f3ae99",
                "planParams": {
                    "maxPartitionsPerPIndex": 1024,
                    "indexPartitions": 1
                },
                "params": {
                    "doc_config": {
                        "docid_prefix_delim": "",
                        "docid_regexp": "",
                        "mode": "scope.collection.type_field",
                        "type_field": "type"
                    },
                    "mapping": {
                        "analysis": {},
                        "default_analyzer": "standard",
                        "default_datetime_parser": "dateTimeOptional",
                        "default_field": "_all",
                        "default_mapping": {
                            "dynamic": true,
                            "enabled": false
                        },
                        "default_type": "_default",
                        "docvalues_dynamic": false,
                        "index_dynamic": true,
                        "store_dynamic": false,
                        "type_field": "_type",
                        "types": {
                            "inventory.hotel": {
                                "dynamic": false,
                                "enabled": true,
                                "properties": {
                                    "reviews": {
                                        "dynamic": false,
                                        "enabled": true,
                                        "properties": {
                                            "content": {
                                                "dynamic": false,
                                                "enabled": true,
                                                "fields": [
                                                    {
                                                        "docvalues": true,
                                                        "include_in_all": true,
                                                        "include_term_vectors": true,
                                                        "index": true,
                                                        "name": "content",
                                                        "store": true,
                                                        "type": "text"
                                                    }
                                                ]
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "store": {
                        "indexType": "scorch",
                        "segmentVersion": 15
                    }
                },
                "sourceParams": {}
            },
            "travel-sample.inventory.travel-test": {
                "type": "fulltext-index",
                "name": "travel-test",
                "uuid": "766ddce5d41a3b41",
                "sourceType": "gocbcore",
                "sourceName": "travel-sample",
                "sourceUUID": "8f866261438f8b0d415a437552f3ae99",
                "planParams": {
                    "maxPartitionsPerPIndex": 1024,
                    "indexPartitions": 1
                },
                "params": {
                    "doc_config": {
                        "docid_prefix_delim": "",
                        "docid_regexp": "",
                        "mode": "scope.collection.type_field",
                        "type_field": "type"
                    },
                    "mapping": {
                    "analysis": {},
                    "default_analyzer": "standard",
                    "default_datetime_parser": "dateTimeOptional",
                    "default_field": "_all",
                    "default_mapping": {
                        "dynamic": true,
                        "enabled": true
                    },
                    "default_type": "_default",
                    "docvalues_dynamic": false,
                    "index_dynamic": true,
                    "store_dynamic": false,
                    "type_field": "_type"
                    },
                    "store": {
                        "indexType": "scorch",
                        "segmentVersion": 15
                    }
                },
                "sourceParams": {}
            }
        },
        "implVersion": "5.7.0"
    }
}
----


[[g-api-index-name]]GET /api/index/\{indexName}::
Returns the definition of an index as JSON.
+
*Permission Required*: cluster.bucket[[.var]`bucket_name`].fts!read
+
*Role Required*:  FTS-Admin
+
*Parameters*

* [.param]`indexName`: required, string, URL path parameter
+
The name of the index definition to be retrieved.
+
.Sample response
----
{
    "indexDef": {
        "name": "myFirstIndex",
        "params": "",
        "planParams": {
            "hierarchyRules": null,
            "maxPartitionsPerPIndex": 0,
            "nodePlanParams": null,
            "numReplicas": 0,
            "planFrozen": false
        },
        "sourceName": "",
        "sourceParams": "",
        "source
            ": "nil",
        "sourceUUID": "",
        "type": "fulltext-index",
        "uuid": "6cc599ab7a85bf3b"
      },
      "planPIndexes": [
        {
         "indexName": "myFirstIndex",
         "indexParams": "",
         "indexType": "bleve",
         "indexUUID": "6cc599ab7a85bf3b",
         "name": "myFirstIndex_6cc599ab7a85bf3b_0",
         "nodes": {
            "78fc2ffac2fd9401": {
              "canRead": true,
              "canWrite": true,
              "priority": 0
            }
         },
         "sourceName": "",
         "sourceParams": "",
         "sourcePartitions": "",
         "sourceType": "nil",
         "sourceUUID": "",
         "uuid": "64bed6e2edf354c3"
         }
       ],
       "status": "ok",
       "warnings": []
       }
----

[[g-api-scoped-index-name]]GET /api/bucket/{$BUCKET_NAME}/scope/{$SCOPE_NAME}/index/{$INDEX_NAME}::
Returns the index definition for a Search index as a JSON object. 
Unlike <<g-api-index-name,GET /api/index/\{indexName}>>, this endpoint is scoped and does not require a fully qualified `${INDEX_NAME}` value.
+
*Permission Required*: cluster.bucket[[.var]`$BUCKET_NAME`].fts!read
+
*Role Required*: FTS-Admin
+
*Parameters*

* [.param]`{$BUCKET_NAME}`: required, string, URL path parameter
+
The name of the bucket used to create the Search index definition. 

* [.param]`{$SCOPE_NAME}`: required, string, URL path parameter
+
The name of the scope used to create the Search index definition. 

* [.param]`{$INDEX_NAME}`: required, string, URL path parameter
+
The name of the index definition to return. 
+
.Sample Response
----
{
    "status": "ok",
    "indexDef": {
        "type": "fulltext-index",
        "name": "travel-sample-index",
        "uuid": "7726786ebec28bbb",
        "sourceType": "gocbcore",
        "sourceName": "travel-sample",
        "sourceUUID": "8f866261438f8b0d415a437552f3ae99",
        "planParams": {
            "maxPartitionsPerPIndex": 1024,
            "indexPartitions": 1
        },
        "params": {
            "doc_config": {
                "docid_prefix_delim": "",
                "docid_regexp": "",
                "mode": "type_field",
                "type_field": "type"
            },
            "mapping": {
                "analysis": {},
                "default_analyzer": "standard",
                "default_datetime_parser": "dateTimeOptional",
                "default_field": "_all",
                "default_mapping": {
                    "dynamic": true,
                    "enabled": true
                },
                "default_type": "_default",
                "docvalues_dynamic": false,
                "index_dynamic": true,
                "store_dynamic": false,
                "type_field": "_type"
            },
            "store": {
                "indexType": "scorch",
                "segmentVersion": 15
            }
        },
        "sourceParams": {}
    },
    "planPIndexes": [
        {
            "name": "travel-sample._default.travel-sample-index_7726786ebec28bbb_4c1c5584",
            "uuid": "b32feefae9bddd32",
            "indexType": "fulltext-index",
            "indexName": "travel-sample._default.travel-sample-index",
            "indexUUID": "7726786ebec28bbb",
            "sourceType": "gocbcore",
            "sourceName": "travel-sample",
            "sourceUUID": "8f866261438f8b0d415a437552f3ae99",
            "sourcePartitions": "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999,1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023",
            "nodes": {
                "cda94e76f9e9824a5d9092f0a98139a8": {
                    "canRead": true,
                    "canWrite": true,
                    "priority": 0
                }
            },
            "indexParams": {
                "doc_config": {
                    "docid_prefix_delim": "",
                    "docid_regexp": "",
                    "mode": "type_field",
                    "type_field": "type"
                },
                "mapping": {
                    "analysis": {},
                    "default_analyzer": "standard",
                    "default_datetime_parser": "dateTimeOptional",
                    "default_field": "_all",
                    "default_mapping": {
                        "dynamic": true,
                        "enabled": true
                    },
                    "default_type": "_default",
                    "docvalues_dynamic": false,
                    "index_dynamic": true,
                    "store_dynamic": false,
                    "type_field": "_type"
                },
                "store": {
                    "indexType": "scorch",
                    "segmentVersion": 15
                }
            }
        }
    ],
    "warnings": []
}
----

[[p-api-index-name]]PUT /api/index/\{indexName}::
Creates/updates an index definition.
+
*Permission Required*: cluster.bucket[[.var]`bucket_name`].fts!write
+
*Role Required*: FTS-Admin
+
*Parameters*

* [.param]`indexName`: required, string, URL path parameter
+
The name of the to-be-created/updated index definition, validated with the regular expression `^[A-Za-z][0-9A-Za-z_\-]*$`.

* [.param]`indexParams`: optional (depends on the value of the indexType), string (JSON), form parameter
 ** For indexType [.in]`alias`, an example [.param]`indexParams` JSON:
+
----
{
    "targets": {
        "yourIndexName": {
            "indexUUID": ""
        }
     }
}
----

 ** For indexType [.in]`bleve`, an example [.param]`indexParams` JSON:
+
----
{
    "mapping": {
        "default_mapping": {
            "enabled": true,
            "dynamic": true,
            "default_analyzer": ""
         },
         "type_field": "_type",
         "default_type": "_default",
         "default_analyzer": "standard",
         "default_datetime_parser": "dateTimeOptional",
         "default_field": "_all",
         "byte_array_converter": "json",
         "analysis": {}
     },
     "store": {
          "kvStoreName": "mossStore"
     }
     }
----
* [.param]`indexType`: required, string, form parameter
+
Supported index types include:

 ** alias: an alias provides a naming level of indirection to one or more actual, target indexes
 ** bleve: a full-text index powered by the bleve engine

* [.param]`planParams`: optional, string (JSON), form parameter
* [.param]`prevIndexUUID`: optional, string, form parameter
+
Intended for clients that want to check that they are not overwriting the index definition updates of concurrent clients.

* [.param]`sourceName`: optional, string, form parameter
* [.param]`sourceParams`: optional (depends on the value of the sourceType), string (JSON), form parameter
+
For sourceType [.in]`couchbase`, an example sourceParams JSON:
+
----
{
              "authUser": "",
              "authPassword": "",
              "authSaslUser": "",
              "authSaslPassword": "",
              "clusterManagerBackoffFactor": 0,
              "clusterManagerSleepInitMS": 0,
              "clusterManagerSleepMaxMS": 20000,
              "dataManagerBackoffFactor": 0,
              "dataManagerSleepInitMS": 0,
              "dataManagerSleepMaxMS": 20000,
              "feedBufferSizeBytes": 0,
              "feedBufferAckThreshold": 0
}
----

* [.param]`sourceUUID`: optional, string, form parameter
* [.param]`result on error`: Non-200 HTTP error code
* [.param]`result on success`: HTTP 200 with body JSON of `{"status": "ok"}`

[[p-api-scoped-index-name]]PUT /api/bucket/{$BUCKET_NAME}/scope/{$SCOPE_NAME}/index/{$INDEX_NAME}::
Create a new index definition or update an existing index in the specified bucket and scope. 
Unlike <<p-api-index-name,PUT /api/index/\{indexName}>>, this endpoint is scoped and does not require a fully qualified `${INDEX_NAME}` value.
+
*Permission Required*: cluster.bucket[[.var]`$BUCKET_NAME`].fts!write
+
*Role Required*: FTS-Admin
+
*Parameters*

* [.param]`{$BUCKET_NAME}`: required, string, URL path parameter
+
The name of the bucket where the Search Service should create or update the index definition. 

* [.param]`{$SCOPE_NAME}`: required, string, URL path parameter
+
The name of the scope where the Search Service should create or update the index definition. 

* [.param]`{$INDEX_NAME}`: required, string, URL path parameter
+
The name of the index definition to create or update.
+
The index definition must satisfy the regular expression `^[A-Za-z][0-9A-Za-z_\-]*$`.
+
*Request Body*: Add a JSON object with the full Search index definition you want to create or update.
For more information about how to create an index definition JSON, see xref:search:search-index-params.adoc[].
+
.Sample failure response
----
{
    "error": "rest_create_index: index type is required, indexName: travel-test",
    "request": {},
    "status": "fail"
}
----
+
The Search Service returns a non-200 HTTP error code when a request fails. 
+
.Sample success response
----
{
    "status": "ok",
    "name": "travel-sample.inventory.travel-test",
    "uuid": "654cb62baebf2d26"
}
----
+
The Search Service returns an HTTP 200 with a response that includes `"status": "ok"`.

[[d-api-index-name]]DELETE /api/index/\{indexName}::
Deletes an index definition.
+
*Permission Required*: cluster.bucket[[.var]`bucket_name`].fts!write
+
*Role Required*: FTS-Admin
+
*Parameters*

* [.param]`indexName`: required, string, URL path parameter
+
The name of the index definition to be deleted.


[[d-api-scoped-index-name]]DELETE /api/bucket/{$BUCKET_NAME}/scope/{$SCOPE_NAME}/index/{$INDEX_NAME}::
Delete the specified index definition from the bucket and scope. 
Unlike <<d-api-index-name,DELETE /api/index/\{indexName}>>, this endpoint is scoped and does not require a fully qualified `${INDEX_NAME}` value.
+
*Permission Required*: cluster.bucket[[.var]`$BUCKET_NAME`].fts!write
+
*Role Required*: FTS-Admin
+
*Parameters*

* [.param]`{$BUCKET_NAME}`: required, string, URL path parameter
+
The name of the bucket used to create the index definition. 

* [.param]`{$SCOPE_NAME}`: required, string, URL path parameter
+
The name of the scope used to create the index definition. 

* [.param]`{$INDEX_NAME}`: required, string, URL path parameter
+
The name of the index definition to delete.
+
.Sample failure response
----
{
    "error": "rest_auth: preparePerms, err: index not found",
    "request": "",
    "status": "fail"
}
----
+
The Search Service returns a non-200 HTTP error code when a request fails. 
+
.Sample success response
----
{
    "status": "ok",
    "uuid": "687be6a2ad647c34"
}
----
+
The Search Service returns an HTTP 200 with a response that includes `"status": "ok"`.

== Index Management

[[p-api-idx-name-ingestcontrol]]POST /api/index/\{indexName}/ingestControl/\{op}::
Pause index updates and maintenance (no more ingesting document mutations).
+
*Permission Required*: cluster.bucket[[.var]`bucket_name`].fts!manage
+
*Role Required*: FTS-Admin
+
*Parameters*

* [.param]`indexName`: required, string, URL path parameter
+
The name of the index whose control values will be modified.

* [.param]`op`: required, string, URL path parameter
+
Allowed values for op are "pause" or "resume".

[[p-api-scoped-ingestcontrol]]POST /api/bucket/{$BUCKET_NAME}/scope/{$SCOPE_NAME}/index/{$INDEX_NAME}/ingestControl/{$OP}::
Use this endpoint to either pause or resume index updates and maintenance. 
While paused, the Search index stops ingesting document mutations. 
Unlike <<p-api-idx-name-ingestcontrol,POST /api/index/\{indexName}/ingestControl/{op}>>, this endpoint is scoped and does not require a fully qualified `${INDEX_NAME}` value.
+
*Permission Required*: cluster.bucket[[.var]`$BUCKET_NAME`].fts!manage
+
*Role Required*: FTS-Admin
+
*Parameters*

* [.param]`{$BUCKET_NAME}`: required, string, URL path parameter
+
The name of the bucket used to create the index definition. 

* [.param]`{$SCOPE_NAME}`: required, string, URL path parameter
+
The name of the scope used to create the index definition. 

* [.param]`{$INDEX_NAME}`: required, string, URL path parameter
+
The name of the index definition to pause or resume.

* [.param]`{$OP}`: required, string, URL path parameter
+
To pause ingestion and maintenance, set `{$OP}` to `pause`.
To resume ingestion and maintenance on a paused index, set `{$OP}` to `resume`.
+
.Sample success response
----
{
    "status": "ok",
}
----
+
The Search Service returns an HTTP 200 with a response that includes `"status": "ok"`.

[[p-api-idx-name-planfreezecontrol]]POST /api/index/\{indexName}/planFreezeControl/\{op}::
Freeze the assignment of index partitions to nodes.
+
*Permission Required*: cluster.bucket[[.var]`bucket_name`].fts!manage
+
*Role Required*: FTS-Admin
+
*Parameters*

* [.param]`indexName`: required, string, URL path parameter
+
The name of the index whose control values will be modified.

* [.param]`op`: required, string, URL path parameter
+
Allowed values for op are "freeze" or "unfreeze".

[[p-api-scoped-planfreezecontrol]]POST /api/bucket/{$BUCKET_NAME}/scope/{$SCOPE_NAME}/index/{$INDEX_NAME}/planFreezeControl/{$OP}::
Use this endpoint to freeze or unfreeze the assignment of Search index partitions to nodes.
Unlike <<p-api-idx-name-planfreezecontrol,POST /api/index/\{indexName}/planFreezeControl/{op}>>, this endpoint is scoped and does not require a fully qualified `${INDEX_NAME}` value. 
+
*Permission Required*: cluster.bucket[[.var]`$BUCKET_NAME`].fts!manage
+
*Role Required*: FTS-Admin
+
*Parameters*

* [.param]`{$BUCKET_NAME}`: required, string, URL path parameter
+
The name of the bucket used to create the index definition. 

* [.param]`{$SCOPE_NAME}`: required, string, URL path parameter
+
The name of the scope used to create the index definition. 

* [.param]`{$INDEX_NAME}`: required, string, URL path parameter
+
The name of the index definition to freeze or unfreeze for partition assignment.

* [.param]`{$OP}`: required, string, URL path parameter
+
To freeze partition assignment, set `{$OP}` to `freeze`.
To unfreeze partition assignment on a frozen index, set `{$OP}` to `unfreeze`.
+
.Sample success response
----
{
    "status": "ok",
}
----
+
The Search Service returns an HTTP 200 with a response that includes `"status": "ok"`.

[[p-api-idx-name-querycontrol]]POST /api/index/\{indexName}/queryControl/\{op}::
Disallow queries on an index.
+
*Permission Required*: cluster.bucket[[.var]`bucket_name`].fts!manage
+
*Role Required*: FTS-Admin
+
*Parameters*

* [.param]`indexName`: required, string, URL path parameter
+
The name of the index whose control values will be modified.

* [.param]`op`: required, string, URL path parameter
+
Allowed values for op are "allow" or "disallow".

[[p-api-scoped-querycontrol]]POST /api/bucket/{$BUCKET_NAME}/scope/{$SCOPE_NAME}/index/{$INDEX_NAME}/queryControl/{$OP}::
Use this endpoint to allow or disallow queries in a Search index.
Unlike <<p-api-idx-name-querycontrol,POST /api/index/\{indexName}/queryControl/{op}>>, this endpoint is scoped and does not require a fully qualified `${INDEX_NAME}` value. 
+
*Permission Required*: cluster.bucket[[.var]`$BUCKET_NAME`].fts!manage
+
*Role Required*: FTS-Admin
+
*Parameters*

* [.param]`{$BUCKET_NAME}`: required, string, URL path parameter
+
The name of the bucket used to create the index definition. 

* [.param]`{$SCOPE_NAME}`: required, string, URL path parameter
+
The name of the scope used to create the index definition. 

* [.param]`{$INDEX_NAME}`: required, string, URL path parameter
+
The name of the index definition where you want to allow or disallow Search queries.

* [.param]`{$OP}`: required, string, URL path parameter
+
To allow queries against a Search index, set `{$OP}` to `allow`.
To block queries against a Search index, set `{$OP}` to `disallow`.
+
.Sample success response
----
{
    "status": "ok",
}
----
+
The Search Service returns an HTTP 200 with a response that includes `"status": "ok"`.

== Index Monitoring And Debugging

[[g-api-stats]]GET /api/stats::
Returns indexing and data related metrics, timings and counters from the node as JSON.
+
*Permission Required*: cluster.bucket[[.var]`bucket_name`].stats!read
+
*Role Required*: FTS-Admin
+
.Sample response
----
{
    "feeds": {
        "myFirstIndex_6cc599ab7a85bf3b": {}
    },
    "manager": {
        "TotCreateIndex": 1,
        "TotCreateIndexOk": 1,
        "TotDeleteIndex": 0,
        "TotDeleteIndexOk": 0,
        "TotIndexControl": 0,
        "TotIndexControlOk": 0,
        "TotJanitorClosePIndex": 0,
        "TotJanitorKick": 2,
        "TotJanitorKickErr": 0,
        "TotJanitorKickOk": 2,
        "TotJanitorKickStart": 2,
        "TotJanitorNOOP": 0,
        "TotJanitorNOOPOk": 0,
        "TotJanitorRemovePIndex": 0,
        "TotJanitorSubscriptionEvent": 0,
        "TotJanitorUnknownErr": 0,
        "TotKick": 0,
        "TotPlannerKick": 2,
        "TotPlannerKickChanged": 1,
        "TotPlannerKickErr": 0,
        "TotPlannerKickOk": 2,
        "TotPlannerKickStart": 2,
        "TotPlannerNOOP": 0,
        "TotPlannerNOOPOk": 0,
        "TotPlannerSubscriptionEvent": 0,
        "TotPlannerUnknownErr": 0,
        "TotSaveNodeDef": 2,
        "TotSaveNodeDefGetErr": 0,
        "TotSaveNodeDefOk": 2,
        "TotSaveNodeDefSame": 0,
        "TotSaveNodeDefSetErr": 0
     },
     "pindexes": {
         "myFirstIndex_6cc599ab7a85bf3b_0": null
     }
}
----

[[g-api-stats-index-name]]GET /api/stats/index/\{indexName}::
Returns metrics, timings and counters for a single index from the node as JSON.
+
*Permission Required*: cluster.bucket[[.var]`bucket_name`].stats!read
+
*Role Required*: FTS-Admin
+
.Sample response
----
{
    "feeds": {
        "myFirstIndex_6cc599ab7a85bf3b": {}
    },
    "pindexes": {
        "myFirstIndex_6cc599ab7a85bf3b_0": null
    }
}
----

[[g-api-stats-index-name-analyzeDoc]]POST /api/index/\{indexName}/analyzeDoc::
Sends a json document to the given index for text analysis.
+
*Permission Required*: cluster.bucket[[.var]`bucket_name`].fts!read
+
*Role Required*: FTS-Searcher, FTS-Admin
+
*Parameters*

* [.param]`indexName`: required, string, URL path parameter
+
The name of the index against which the analysis needs to performed.
+
The request's POST body contains any sample json document.
For example:
+
----
{
   "name": "hello world",
   "title": "couchbase blr"}
}
----

=== Response Object

A sample response for an index definition with keyword analyzer set against the title field and an ngram
(min=2, max=5) tokenfilter set against the name field would be like below for the above request.

----
{
  "status": "ok",
  "analyzed": [
    {
      "couchbase blr": {
        "Term": "Y291Y2hiYXNlIGJscg==",
        "Locations": [
          {
            "Field": "title",
            "ArrayPositions": [],
            "Start": 0,
            "End": 13,
            "Position": 1
          }
        ]
      }
    },
    {
      "he": {
        "Term": "aGU=",
        "Locations": [
          {
            "Field": "name",
            "ArrayPositions": [],
            "Start": 0,
            "End": 5,
            "Position": 1
          }
        ]
      },
      "hel": {
        "Term": "aGVs",
        "Locations": [
          {
            "Field": "name",
            "ArrayPositions": [],
            "Start": 0,
            "End": 5,
            "Position": 1
          }
        ]
      },
      "hell": {
        "Term": "aGVsbA==",
        "Locations": [
          {
            "Field": "name",
            "ArrayPositions": [],
            "Start": 0,
            "End": 5,
            "Position": 1
          }
        ]
      },
      "hello": {
        "Term": "aGVsbG8=",
        "Locations": [
          {
            "Field": "name",
            "ArrayPositions": [],
            "Start": 0,
            "End": 5,
            "Position": 1
          }
        ]
      },
      "wo": {
        "Term": "d28=",
        "Locations": [
          {
            "Field": "name",
            "ArrayPositions": [],
            "Start": 6,
            "End": 11,
            "Position": 2
          }
        ]
      },
      "wor": {
        "Term": "d29y",
        "Locations": [
          {
            "Field": "name",
            "ArrayPositions": [],
            "Start": 6,
            "End": 11,
            "Position": 2
          }
        ]
      },
      "worl": {
        "Term": "d29ybA==",
        "Locations": [
          {
            "Field": "name",
            "ArrayPositions": [],
            "Start": 6,
            "End": 11,
            "Position": 2
          }
        ]
      },
      "world": {
        "Term": "d29ybGQ=",
        "Locations": [
          {
            "Field": "name",
            "ArrayPositions": [],
            "Start": 6,
            "End": 11,
            "Position": 2
          }
        ]
      }
    },
    null
  ]
}
----

[[g-api-scoped-status]]GET /api/bucket/{$BUCKET_NAME}/scope/{$SCOPE_NAME}/index/{$INDEX_NAME}/status::
Returns the status of the index, 

== Index Querying

[[g-api-index-name-count]]GET /api/index/\{indexName}/count::
Returns the count of indexed documents.
+
*Permission Required*: cluster.bucket[[.var]`bucket_name`].fts!read
+
*Role Required*: FTS-Searcher, FTS-Admin
+
*Parameters*

* [.param]`indexName`: required, string, URL path parameter
+
The name of the index whose count is to be retrieved.

[[p-api-index-name-query]]POST /api/index/\{indexName}/query::
Queries an index.
+
*Permission Required*: cluster.bucket[[.var]`bucket_name`].fts!read
+
*Role Required*: FTS-Searcher, FTS-Admin
+
*Parameters*

* [.param]`indexName`: required, string, URL path parameter
+
The name of the index to be queried.
+
The request's POST body depends on the index type.
For index type bleve, here's a simple query POST body:
+
----
{
    "query": {
        "query": "a sample query",
        "boost": 1
    },
    "size": 10,
    "from": 0,
    "highlight": null,
    "fields": null,
    "facets": null,
    "explain": false
    }
----
+
An example POST body using from/size for results paging, using ctl for a timeout and for "at_plus" consistency level.
On consistency, the index must have incorporated at least mutation sequence-number 123 for partition (vbucket) 0 and mutation sequence-number 234 for partition (vbucket) 1 (where vbucket 1 should have a vbucketUUID of a0b1c2):
+
----
{
    "ctl": {
        "timeout": 10000,
        "consistency": {
            "level": "at_plus",
                "vectors": {
                    "customerIndex": {
                        "0": 123,
                        "1/a0b1c2": 234
                    }
                }
            }
        },
        "query": {
            "query": "alice smith",
            "boost": 1
        },
        "size": 10,
        "from": 20,
        "highlight": {
            "style": null,
            "fields": null
        },
        "fields": [
            "*"
        ],
        "facets": null,
        "explain": true
}
----

=== Response Object

The response object has a status section that must be checked for every request.
Under nearly all circumstances, the query response will be HTTP 200 even though individual index shards (pindexes) may encounter a timeout or return an error.

*Consistency and Timeouts*

A query can specify a timeout value, a consistency requirement, or both.
This section explains how this affects the query behavior and how to handle the resulting query return values.

* logical first phase consistency wait - if timeout in this period, get 416 error with message saying request could not be satisfied).
* If consistency wait times out with 416, return value to client will indicate the sequence number range processed so the client will have an idea how far the processing got and has the option of retrying more intelligently.
* In phase 2, you have the normal pindex timeout.
This will start whenever the first phase completes.
At this point, request will return 200 HTTP response code unless there is an internal server error.
* Client must check response status, which will return any errors or timeouts for each pindex.
If The response includes the number of errors, and the client can determine whether they need the complete results or can continue as long as enough pindexes return to give a reasonable user experience.
Note that the query return status will be 200 even if all pindexes return errors so it's critical to check the response status and code accordingly.
* If client sets timeout very low, e.g.
1ms, you may receive a 200 error with all timeouts instead of a consistency wait timeout.
