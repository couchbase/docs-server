= XDCR with Scopes and Collections

[abstract]
When XDCR is established between a source bucket and a target bucket, data can be either _implicitly_ or _explicitly_ replicated between _collections_.

[#understanding-xdcr-collections-mapping]
== Understanding XDCR Collections-Mapping

XDCR allows only a single replication to be established between a specific source bucket and a specific target bucket.
However, within the replication, documents can be _mapped_ between different source and target _collections_.
(An overview of scopes and collections is provided in xref:learn:data/scopes-and-collections.adoc[Scopes and Collections].)

A _mapping_ is a link, established by XDCR, between a _namespace_ within the source bucket and a namespace within the target bucket.
A _namespace_ indicates the scope and collection, within the source or target bucket, within which exists data to be replicated.
Each namespace is represented as the name of the scope, followed by the name of the collection, separated by a period.
For example, if a bucket contains a scope named `HotelCollection`, and this scope contains collections named `USHotelCollection` and `UKHotelCollection`, then `HotelCollection.USHotelCollection` and `HotelCollection.UKHotelCollection` are both valid namespaces, specifying different collections within the same scope and bucket.

Between a namespace on the source cluster and a namespace on the target cluster, two kinds of collections-mapping are supported, which are _implicit_ and _explicit_:

* _Implicit_ mapping occurs whenever the source and target buckets contain an identical namespace: XDCR between these namespaces is initiated automatically, as soon as the source and target buckets alone have been specified by the administrator.

* _Explicit_ mapping is administrator-specified, and allows replication to occur between namespaces that are not identical.

These forms of mapping are further described below.

[#implicit-mapping]
== Implicit Mapping

Implicit mapping occurs whenever the source and target buckets contain an identical namespace: XDCR between these namespaces is initiated automatically, as soon as the source and target buckets alone have been specified by the administrator.
This can be illustrated as follows:

image::clusters-and-availability/xdcr-implicit-mapping-diagram.png[,540,align=left]

The annotations are as follows:

. The administrator must explicitly specify a target and a source bucket, between which replication is to occur.
The buckets are typically on different clusters, in different data centers: however, they may also be on different clusters in the same data center, or even on the same cluster.

. Every bucket contains a default scope and collection, whose namespace is `_default._default`.
Implicit replication always occurs, therefore, between the default collection on the source bucket and the default collection on the target bucket.

. In this example, the source bucket contains a scope named `ScopeA`, within which a collection named `CollectionA` exists.
The target bucket also contains `CollectionA` within `ScopeA`.
Therefore, since source and target buckets contain the identical namespace, `ScopeA.CollectionA`, implicit replication occurs automatically between `ScopeA.CollectionA` on the source, and `ScopeACollectionA` on the target.
+
(Note that XDCR does not automatically create scopes or collections.
Therefore, for an implicit mapping to be achieved, identical namespaces must have been previously created by the administrator.)

. Within `ScopeA` in the source bucket, a collection named `CollectionB` exists.
The target bucket also contains `CollectionB` within `ScopeA`.
Therefore, since source and target buckets contain the identical namespace, `ScopeA.CollectionB`, implicit replication occurs automatically between `ScopeA.CollectionB` on the source, and `ScopeACollectionB` on the target.

. The source bucket contains a scope named `ScopeB`, within which a collection named `CollectionA` exists.
The target bucket also contains `CollectionA`, within `ScopeB`.
Therefore, since source and target buckets contain the identical namespace, `ScopeB.CollectionA`, implicit replication occurs automatically between `ScopeB.CollectionA` on the source, and `ScopeB.CollectionA` on the target.

. Within `ScopeB` in the source bucket, a collection named `CollectionB` exists.
However, although the target bucket contains a scope named `ScopeB`, this does _not_ contain a collection named `CollectionB`: instead, it contains a collection named `CollectionC`.
Therefore, since `ScopeB.CollectionB` is a namespace unique to the source, no implicit mapping is established with the target, and no replication is automatically initiated.
+
Note, however, if an identical namespace is _subsequently_ established within the target bucket, a _backfill_ process is automatically applied, to replicate all appropriate data from the source to the target collection: this is described in detail below.

[#explicit-mapping]
== Explicit Mappping

_Explicit_ mapping is administrator-specified, and allows replication to occur between namespaces that are not identical.
An explicit mapping can be specified either between scopes, or between collections:

* _An explicit mapping between scopes_ ensures that an _implicit_ mapping occurs between collections within the scopes that are identically named.
For example, if on the source, `ScopeA` contains `CollectionA`, and on the target, `ScopeB` contains `CollectionA`, an explicit mapping between `ScopeA` on the source and `ScopeB` on the target automatically produces an implicit mapping between the two collections named `CollectionA`.
+
An explicit mapping between scopes produces no implicit mapping between dissimilarly named collections.
For example, if on the source, `ScopeA` contains `CollectionA`, and on the target, `ScopeB` contains `CollectionB`, an explicit mapping between `ScopeA` on the source and `ScopeB` on the target produces no implicit mapping between `CollectionA` and `CollectionB`.

* _An explicit mapping between collections_ allows a collection on the source to be mapped to a dissimilarly named collection on the target.
Such collections may reside within dissimilarly named scopes.
For example, an explicit mapping might be specified between `ScopeA.CollectionX` on the source, and `ScopeB.CollectionY` on the target.

Explicit mapping can be illustrated as follows:

image::clusters-and-availability/xdcr-explicit-mapping-diagram.png[,540,align=left]

The annotations are as follows:

. The administrator must explicitly specify a target and a source bucket, between which replication is to occur.

. In this example, the source bucket contains the scope `ScopeA`, and the target bucket contains the scope `ScopeX`.
When the administrator specifies an explicit mapping between `ScopeA` and `ScopeB`, an implicit mapping occurs between any identically named collections within the source and target buckets.
Therefore, `ScopeA.CollectionA` is mapped implicitly to `ScopeX.CollectionA` (2a); and `ScopeA.CollectionB` is mapped implicitly to `ScopeX.CollectionB` (2b).

. In this example, the source bucket contains the scope `ScopeB`, and the target bucket contains the scope `ScopeY`.
Each scope contains two collections, named `CollectionA` and `CollectionB`/
An explicit mapping between `ScopeB` and `ScopeY` would therefore produce an implicit mapping between `ScopeB.CollectionA` and `ScopeY.CollectionA`; and between `ScopeB.CollectionB` and `ScopeY.CollectionB`.
However, as an alternative to an explicit mapping between `ScopeB` and `ScopeY`, an _explicit_ mapping might be achieved between any collection in `ScopeB` and any collection in `ScopeY`: for example, between `ScopeB.CollectionA` and `ScopeY.CollectionB`, as shown in the diagram.

[#target-collection-removal-and-addition]
== Target-Collection Removal and Addition

The conditions under which a document is replicated from a source bucket to a target bucket are explained in xref:learn:clusters-and-availability/xdcr-overview.adoc#xdcr-process[XDCR Process].
These include the existence of a valid collection-to-collection mapping, which may be any of the following:

* The _implicit_ mapping that always exists between the `_default` collections of the source and target buckets.

* The _implicit_ mapping that is automatically recognized between identical namespaces within the source and target buckets.

* An _explicit_ mapping that has been previously configured by the administrator; and which correctly corresponds to an existing pair of non-identical namespaces on the source and target buckets.

If no such mapping exists for a given document, the document is not replicated.

XDCR continuously monitors the target bucket for the addition or removal of collections.
Where collection-removal on the target bucket invalidates a mapping, documents previously eligible for replication are no longer so, and are therefore, on examination, dropped from memory by XDCR, and are not replicated.

Where collection-addition occurs on the target bucket such that a new _implicit_ mapping is created, but occurs _after_ replication between the source and target bucket has been commenced, the following occur:

* XDCR creates a _backfill pipeline_, which replicates to the target collection as appropriate all documents from the source collection that were previously dropped by XDCR, due to the previous lack of an implicit mapping.
The documents to be considered candidates for this replication are determined based on the _replication sequence number_ that XDCR was handling at the point the new implicit mapping was recognized: documents whose sequence number was lower than this are re-examined.

* The standard XDCR pipeline continue to operate, replicating ongoing mutations to the new, target collection.

The backfill pipeline is always started with _Low_ priority, to minimize the performance impact on the main pipelines. Once the backfill pipeline has finished replicating the missing data, the backfill pipeline-process is terminated, and the main pipeline continues.
Note that the creation, activation, and removal of the backfill pipeline are entirely automated, and are invisible to the administrator (with the possible exception of occasional cases where recently created documents are noted to arrive at the target bucket prior to earlier mutations).
