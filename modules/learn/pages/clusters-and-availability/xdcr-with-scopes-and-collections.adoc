= XDCR with Scopes and Collections

[abstract]
When XDCR is established between a source bucket and a target bucket, data can be either _implicitly_ or _explicitly_ replicated between _collections_.

[#understanding-xdcr-collections-mapping]
== Understanding XDCR Collections-Mapping

XDCR allows only a single replication to be established between a specific source bucket and a specific target bucket.
However, within the replication, documents can be _mapped_ between different source and target _collections_.
(An overview of scopes and collections is provided in xref:learn:data/scopes-and-collections.adoc[Scopes and Collections].)

A _mapping_ is a link, established by XDCR, between a _namespace_ within the source bucket and a namespace within the target bucket.
A _namespace_ indicates the scope and collection, within the source or target bucket, within which exists data to be replicated.
Each namespace is represented as the name of the scope, followed by the name of the collection, separated by a period.
For example, if a bucket contains a scope named `HotelCollection`, and this scope contains collections named `USHotelCollection` and `UKHotelCollection`, then `HotelCollection.USHotelCollection` and `HotelCollection.UKHotelCollection` are both valid namespaces, specifying different collections within the same scope and bucket.

Between a namespace on the source cluster and a namespace on the target cluster, two kinds of collections-mapping are supported, which are _implicit_ and _explicit_:

* _Implicit_ mapping occurs whenever the source and target buckets contain an identical namespace: XDCR between each pair of identical namespaces is initiated automatically, as soon as replication starts between the source and target buckets.

* _Explicit_ mapping is administrator-determined, and allows replication to occur between namespaces that are not identical.
The correct pairings of namespaces on source and target must therefore be specified by the administrator.

These forms of mapping are further described below.

[#implicit-mapping]
== Implicit Mapping

Implicit mapping occurs whenever the source and target buckets contain an identical namespace: replication of documents between these namespaces occurs automatically, as soon as XDCR between the source and target buckets is commenced.
This can be illustrated as follows:

image::clusters-and-availability/xdcr-implicit-mapping-diagram.png[,540,align=left]

The annotations are as follows:

. The administrator must explicitly specify a target and a source bucket, between which replication is to occur.
The buckets are typically on different clusters, in different data centers: however, they may also be on different clusters in the same data center, or even on the same cluster.

. Every bucket contains a default scope and collection, whose namespace is `_default._default`.
Implicit replication always occurs, therefore, between the default collection on the source bucket and the default collection on the target bucket.

. In this example, the source bucket contains a scope named `ScopeA`, within which a collection named `CollectionA` exists.
The target bucket also contains `CollectionA` within `ScopeA`.
Therefore, since source and target buckets contain the identical namespace, `ScopeA.CollectionA`, implicit replication occurs automatically between `ScopeA.CollectionA` on the source, and `ScopeACollectionA` on the target.
+
(Note that XDCR does not automatically create scopes or collections.
Therefore, for an implicit mapping to be achieved, identical namespaces must have been previously created by the administrator.)

. Within `ScopeA` in the source bucket, a collection named `CollectionB` exists.
The target bucket also contains `CollectionB` within `ScopeA`.
Therefore, since source and target buckets contain the identical namespace, `ScopeA.CollectionB`, implicit replication occurs automatically between `ScopeA.CollectionB` on the source, and `ScopeACollectionB` on the target.

. The source bucket contains a scope named `ScopeB`, within which a collection named `CollectionA` exists.
The target bucket also contains `CollectionA`, within `ScopeB`.
Therefore, since source and target buckets contain the identical namespace, `ScopeB.CollectionA`, implicit replication occurs automatically between `ScopeB.CollectionA` on the source, and `ScopeB.CollectionA` on the target.

. Within `ScopeB` in the source bucket, a collection named `CollectionB` exists.
However, although the target bucket contains a scope named `ScopeB`, this does _not_ contain a collection named `CollectionB`: instead, it contains a collection named `CollectionC`.
Therefore, since `ScopeB.CollectionB` is a namespace unique to the source, no implicit mapping is established with the target, and no replication is automatically initiated.
+
Note, however, if an identical namespace is _subsequently_ established within the target bucket, a _backfill pipeline_ is automatically created, to replicate all appropriate data from the source to the target collection: this is described below, in xref:learn:collections-and-availability/xdcr-overview.adoc#target-collection-removal-and-addition[Target-Collection Removal and Addition].

For the practical steps required to set up implicit mappings, see xref:manage:manage-xdcr/replicate-using-scopes-and-collections.adoc#replicate-data-between-collections-implicitly[Replicate Data Between Collections Implicitly].

[#explicit-mapping]
== Explicit Mappping

_Explicit_ mapping is administrator-specified, and allows replication to occur between namespaces that are not identical.
An explicit mapping can be specified either between scopes, or between collections:

* _An explicit mapping between scopes_ ensures that an _implicit_ mapping occurs between collections within the scopes that are identically named.
For example, if on the source, `ScopeA` contains `CollectionA`, and on the target, `ScopeB` contains `CollectionA`, an explicit mapping between `ScopeA` on the source and `ScopeB` on the target automatically produces an implicit mapping between the two collections named `CollectionA`.
+
An explicit mapping between scopes produces no implicit mapping between dissimilarly named collections.
For example, if on the source, `ScopeA` contains `CollectionA`, and on the target, `ScopeB` contains `CollectionB`, an explicit mapping between `ScopeA` on the source and `ScopeB` on the target produces no implicit mapping between `CollectionA` and `CollectionB`.

* _An explicit mapping between collections_ allows a collection on the source to be mapped to a dissimilarly named collection on the target.
Such collections may reside within dissimilarly named scopes.
For example, an explicit mapping might be specified between `ScopeA.CollectionX` on the source, and `ScopeB.CollectionY` on the target.

Explicit mapping can be illustrated as follows:

image::clusters-and-availability/xdcr-explicit-mapping-diagram.png[,540,align=left]

The annotations are as follows:

. The administrator must explicitly specify a target and a source bucket, between which replication is to occur.

. In this example, the source bucket contains the scope `ScopeA`, and the target bucket contains the scope `ScopeX`.
When the administrator specifies an explicit mapping between `ScopeA` and `ScopeB`, an implicit mapping occurs between any identically named collections within the source and target buckets.
Therefore, `ScopeA.CollectionA` is mapped implicitly to `ScopeX.CollectionA` (2a); and `ScopeA.CollectionB` is mapped implicitly to `ScopeX.CollectionB` (2b).

. In this example, the source bucket contains the scope `ScopeB`, and the target bucket contains the scope `ScopeY`.
Each scope contains two collections, named `CollectionA` and `CollectionB`/
An explicit mapping between `ScopeB` and `ScopeY` would therefore produce an implicit mapping between `ScopeB.CollectionA` and `ScopeY.CollectionA`; and between `ScopeB.CollectionB` and `ScopeY.CollectionB`.
However, as an alternative to an explicit mapping between `ScopeB` and `ScopeY`, an _explicit_ mapping might be achieved between any collection in `ScopeB` and any collection in `ScopeY`: for example, between `ScopeB.CollectionA` and `ScopeY.CollectionB`, as shown in the diagram.

For the practical steps required to set up explicit mappings, see xref:manage:manage-xdcr/replicate-using-scopes-and-collections.adoc#replicate-data-between-collections-explicitly[Replicate Data Between Collections Explicitly].

[#target-collection-removal-and-addition]
== Target-Collection Removal and Addition

The conditions under which a document is replicated from a source bucket to a target bucket are explained in xref:learn:clusters-and-availability/xdcr-overview.adoc#xdcr-process[XDCR Process].
These include the existence of a valid collection-to-collection mapping, which may be any of the following:

* The _implicit_ mapping that always exists between the `_default` collections of the source and target buckets.

* The _implicit_ mapping that is automatically recognized between identical namespaces within the source and target buckets.

* An _explicit_ mapping that has been previously configured by the administrator; and which correctly corresponds to an existing pair of non-identical namespaces on the source and target buckets.

If no such mapping exists for a given document, the document is not replicated.

XDCR continuously monitors the target bucket for the addition or removal of collections.
Where collection-removal on the target bucket invalidates a mapping, documents previously eligible for replication are no longer so, and are therefore, on examination, dropped from memory by XDCR, and are not replicated.

Where collection-addition occurs on the target bucket such that a new _implicit_ mapping is created, but occurs _after_ replication between the source and target bucket has been commenced, the following occur:

* XDCR creates a _backfill pipeline_, which replicates to the target collection as appropriate all documents from the source collection that were previously dropped by XDCR, due to the previous lack of an implicit mapping.
The documents to be considered candidates for this replication are determined based on the _replication sequence number_ that XDCR was handling at the point the new implicit mapping was recognized: documents whose sequence number was lower than this are re-examined.

* The standard XDCR pipeline continue to operate, replicating ongoing mutations to the new, target collection.

Backfill pipelines are always started with _Low_ priority, to minimize the performance degradation of main-pipeline activity.
(See xref:learn:clusters-and-availability/xdcr-overview.adoc#xdcr-priority[XDCR Priority], for information.)
Once a backfill pipeline has finished replicating the missing data, its process is terminated, and the main pipeline for the mapping continues.
Note that the creation, activation, and removal of a backfill pipeline are entirely automated, and are invisible to the administrator (with the possible exception of occasional cases where recently created documents are noted to arrive at the target bucket prior to earlier mutations).

[#migration]
== Migration

When a pre-7.0 version of Couchbase Server is upgraded to 7.0 or later, all documents that resided in a pre-7.0 bucket appear in the _default collection_, within the _default scope_, of the bucket on the 7.0 or later version.
See xref:learn:data/scopes-and-collections.adoc[Scopes and Collections], for information.

Following upgrade, data within the default collection can be _migrated_ to administrator-defined collections, within new target buckets, potentially on the same cluster.
For each new collection, a replication to the appropriate target bucket is defined, and a filter applied, ensuring that only the appropriate subset of documents is replicated.
The mapping between the documents currently in the default collection on the source, and the new collection on the target, is explicitly specified by the administrator.

Migration can be illustrated by the following diagram:

image::clusters-and-availability/xdcr-collections-migration-diagram.png[,540,align=left]

The annotations are as follows:

. The administrator must explicitly specify a target and a source bucket, between which replication is to occur.

. The administrator must explicitly specify a target scope and collection, within the target bucket.
Here, the target scope is `US-Scope`, within which resides the target collection, `Airline-Collection`.
The goal is to migrate all documents that correspond to US airlines to the target collection: therefore, the administrator must specify a filter such as the following: `type == "airline" && country == "United States"`.
Thus, every document whose `type` is `"airline"`, and whose `country` is `"United States"` is migrated.

. Similarly, to migrate all documents that correspond to UK airports to the target collection `Airport-Collection`, within the scope `UK-Scope`, a filter such as the following is required: `type == "airport" && country == United Kingdom"`.

For the practical steps, see xref:manage:manage-xdcr/replicate-using-scopes-and-collections.adoc#migrate-data-to-a-collection[Migrate Data to a Collection].

[#scopes-collections-and-filtering]
== Scopes, Collections, and Filtering

xref:learn:clusters-and-availability/xdcr-filtering.adoc[XDCR Advanced Filtering] can be applied to all implicit and explicit mappings.
However, only one filter can be applied to any given replication.
Therefore, once a filter has been defined, it applies equally to all mappings for the replication.
