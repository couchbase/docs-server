= XDCR with Scopes and Collections

[abstract]
When XDCR is established between a source bucket and a target bucket, data can be either _implicitly_ or _explicitly_ replicated between _collections_.

[#understanding-xdcr-collections-mapping]
== Understanding XDCR Collections-Mapping

XDCR allows only a single replication to be established between a specific source bucket and a specific target bucket.
However, within the replication, documents can be _mapped_ between different source and target _collections_.
(An overview of scopes and collections is provided in xref:learn:data/scopes-and-collections.adoc[Scopes and Collections].)

A _mapping_ is a link, established by XDCR, between a _namespace_ within the source bucket and a namespace within the target bucket.
A _namespace_ indicates the scope and collection, within the source or target bucket, within which exists data to be replicated.
Each namespace is represented as the name of the scope, followed by the name of the collection, separated by a period.
For example, if a bucket contains a scope named `HotelCollection`, and this scope contains collections named `USHotelCollection` and `UKHotelCollection`, then `HotelCollection.USHotelCollection` and `HotelCollection.UKHotelCollection` are both valid namespaces, specifying different collections within the same scope and bucket.

Between a namespace on the source cluster and a namespace on the target cluster, two kinds of collections-mapping are supported, which are _implicit_ and _explicit_:

* _Implicit_ mapping occurs whenever the source and target buckets contain an identical namespace: XDCR between these namespaces is initiated automatically, as soon as the source and target buckets alone have been specified by the administrator.

* _Explicit_ mapping is administrator-specified, and allows replication to occur between namespaces that are not identical.

These forms of mapping are further described below.

[#implicit-mapping]
== Implicit Mapping

Implicit mapping occurs whenever the source and target buckets contain an identical namespace: XDCR between these namespaces is initiated automatically, as soon as the source and target buckets alone have been specified by the administrator.
This can be illustrated as follows:

image::clusters-and-availability/xdcr-implicit-mapping-diagram.png[,540,align=left]

The annotations are as follows:

. The administrator must explicitly specify a target and a source bucket, between which replication is to occur.
The buckets are typically on different clusters, in different data centers: however, they may also be on different clusters in the same data center, or even on the same cluster.

. Every bucket contains a default scope and collection, whose namespace is `_default._default`.
Implicit replication always occurs, therefore, between the default collection on the source bucket and the default collection on the target bucket.

. In this example, the source bucket contains a scope named `ScopeA`, within which a collection named `CollectionA` exists.
The target bucket also contains `CollectionA` within `ScopeA`.
Therefore, since source and target buckets contain the identical namespace, `ScopeA.CollectionA`, implicit replication occurs automatically between `ScopeA.CollectionA` on the source, and `ScopeACollectionA` on the target.
+
(Note that XDCR does not automatically create scopes or collections.
Therefore, for an implicit mapping to be achieved, identical namespaces must have been previously created by the administrator.)

. Within `ScopeA` in the source bucket, a collection named `CollectionB` exists.
The target bucket also contains `CollectionB` within `ScopeA`.
Therefore, since source and target buckets contain the identical namespace, `ScopeA.CollectionB`, implicit replication occurs automatically between `ScopeA.CollectionB` on the source, and `ScopeACollectionB` on the target.

. The source bucket contains a scope named `ScopeB`, within which a collection named `CollectionA` exists.
The target bucket also contains `CollectionA`, within `ScopeB`.
Therefore, since source and target buckets contain the identical namespace, `ScopeB.CollectionA`, implicit replication occurs automatically between `ScopeB.CollectionA` on the source, and `ScopeB.CollectionA` on the target.

. Within `ScopeB` in the source bucket, a collection named `CollectionB` exists.
However, although the target bucket contains a scope named `ScopeB`, this does _not_ contain a collection named `CollectionB`: instead, it contains a collection named `CollectionC`.
Therefore, since `ScopeB.CollectionB` is a namespace unique to the source, no implicit mapping is established with the target, and no replication is automatically initiated.
+
Note, however, if an identical namespace is _subsequently_ established within the target bucket, a _backfill_ process is automatically applied, to replicate all appropriate data from the source to the target collection: this is described in detail below.

[#explicit-mapping]
== Explicit Mappping

_Explicit_ mapping is administrator-specified, and allows replication to occur between namespaces that are not identical.
An explicit mapping can be specified either between scopes, or between collections:

* _An explicit mapping between scopes_ ensures that an _implicit_ mapping occurs between collections within the scopes that are identically named.
For example, if on the source, `ScopeA` contains `CollectionA`, and on the target, `ScopeB` contains `CollectionA`, an explicit mapping between `ScopeA` on the source and `ScopeB` on the target automatically produces an implicit mapping between the two collections named `CollectionA`.
+
An explicit mapping between scopes produces no implicit mapping between dissimilarly named collections.
For example, if on the source, `ScopeA` contains `CollectionA`, and on the target, `ScopeB` contains `CollectionB`, an explicit mapping between `ScopeA` on the source and `ScopeB` on the target produces no implicit mapping between `CollectionA` and `CollectionB`.

* _An explicit mapping between collections_ allows a collection on the source to be mapped to a dissimilarly named collection on the target.
Such collections may reside within dissimilarly named scopes.
For example, an explicit mapping might be specified between `ScopeA.CollectionX` on the source, and `ScopeB.CollectionY` on the target.

Explicit mapping can be illustrated as follows:

image::clusters-and-availability/xdcr-explicit-mapping-diagram.png[,540,align=left]

The annotations are as follows:

. The administrator must explicitly specify a target and a source bucket, between which replication is to occur.

. In this example, the source bucket contains the scope `ScopeA`, and the target bucket contains the scope `ScopeX`.
When the administrator specifies an explicit mapping between `ScopeA` and `ScopeB`, an implicit mapping occurs between any identically named collections within the source and target buckets.
Therefore, `ScopeA.CollectionA` is mapped implicitly to `ScopeX.CollectionA` (2a); and `ScopeA.CollectionB` is mapped implicitly to `ScopeX.CollectionB` (2b).

. In this example, the source bucket contains the scope `ScopeB`, and the target bucket contains the scope `ScopeY`.
Each scope contains two collections, named `CollectionA` and `CollectionB`/
An explicit mapping between `ScopeB` and `ScopeY` would therefore produce an implicit mapping between `ScopeB.CollectionA` and `ScopeY.CollectionA`; and between `ScopeB.CollectionB` and `ScopeY.CollectionB`.
However, as an alternatively, an _explicit_ mapping might be achieved between, say, `ScopeB.CollectionA` and `ScopeY.CollectionB`.
