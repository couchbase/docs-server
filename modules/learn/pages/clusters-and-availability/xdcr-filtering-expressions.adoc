= XDCR Filtering Expressions

[abstract]
_XDCR filtering expressions_ allow a document to be included in or excluded from a filtered replication, based on the document's fields and values.

[#understanding-filtering-expressions]
== Understanding Filtering Expressions

XDCR Advanced Filtering _expressions_, applied to the documents within a specified source bucket, allow matches to be made on:

* _id_ and _xattrs_ values, within the document's _metadata_.

* Field-names and values, within the document's _data_, nested to any degree.

Every document on which a match is successfully made is included in the filtered replication.
Other documents are _not_ included.

XDCR filtering expressions constitute a subset of _N1QL_ expressions, with some additions.

Sections on this page list the available expressions, provide examples of their usage, and provide links to documentation for the comparable N1QL expressions.
A list of _reserved words_ is provided.
Additionally, relationships between expressions are listed in in BNF (_Backus-Naur Form_) notation.

Note that examples assume the `travel-sample` bucket to be the source of the filtered replication.
For information on installing this bucket, see xref:manage:manage-settings/install-sample-buckets.adoc[Install Sample Buckets].

XDCR Advanced Filtering can be managed by means of Couchbase Web Console (see xref:manage:manage-xdcr/filter-xdcr-replication.adoc[Filter a Replication]), the CLI (see xref:cli:cbcli/couchbase-cli-xdcr-replicate.adoc[xdcr-replicate]), and the REST API (see xref:rest-api:rest-xdcr-create-replication.adoc[Creating XDCR Replications]).

[#pattern-matching]
== Pattern Matching

Pattern matching is supported with the following syntax:

[cols="1"]
|===
| `REGEXP_CONTAINS` (_expression_, _pattern_)
|===

For example, the following expression specifies `country` as the _expression_, and `"France"` as the pattern:

----
REGEXP_CONTAINS(country, "France")
----

If `travel-sample` is used as the source bucket, every document that contains a field `country` whose value is `"France"` is replicated to the target.
For example, this would include the document `airline_1191`:

----
{
  "callsign": "REUNION",
  "country": "France",
  "iata": "UU",
  "icao": "REU",
  "id": 1191,
  "name": "Air Austral",
  "type": "airline"
}
----

[#mata-data-access]
=== Metadata Access

Each document contains _metadata_, as well as _data_.
Within the metadata, a document's _id_ and _extended attributes_ can be accessed by means of the reserved word `META`, used as part of the the pattern-matching _expression_.

For example, the following expression seeks a match on any document whose metadata _flags_ field has the value `33554432`:

----
REGEXP_CONTAINS(META().flags, 33554432)
----

This would match a number of documents from `travel-sample`, including `airline_10`, whose metadata is as follows:

----
{
  "meta": {
    "id": "airline_10",
    "rev": "1-159642cc11a000000000000002000000",
    "expiration": 0,
    "flags": 33554432,
    "type": "json"
  },
  "xattrs": {}
}
----

_Extended Attributes_ are optionally used to defined application-specific metadata.
The field name is `xattrs`.
In the metadata example shown above, the value is null.
If an extended attribute were defined, such as a `color` field, with a value of `blue`, the appearance would be as follows:

----
  "xattrs": {
    "color": "blue"
  }
----

The extended attribute's value could be filtered and matched with the following expression:

----
REGEXP_CONTAINS(META().xattrs.color, "blue")
----

For information on extended attributes, see xref:learn:data/extended-attributes-fundamentals.adoc[Extended Attributes].

[#lookahead]
=== Lookahead
XDCR Advanced Filtering is supported by _lookahead_.
Lookahead is used to specify a _pattern_, in pattern matching; and permits a match when one specified character or character-sequence:

* Is followed by another specified character or character-sequence.
This is termed _positive_ lookahead.
+
The following syntax is used:
+
[cols="1"]
|===
| _char1_ ( `?=` _char2_ )
|===
+
The specified _char1_ must therefore be located and, for a successful match to be obtained, must be followed by the specified _char2_.

* Is _not_ followed by another specified character or character-sequence.
This is termed _negative_ lookahead.
+
The following syntax is used:
+
[cols="1"]
|===
| _char1_ ( `?!` _char2_ )
|===
+
The specified _char1_ must therefore be located, and, for a successful match to be obtained, must _not_ be followed by the specified _char2_.

Lookahead might therefore be used on the `travel-sample` bucket, to filter documents whose metadata _id_ contains `airport` rather than `airline`, or vice versa.
For example, the following expression uses _positive_ lookahead to specify that the metadata _id_ that begins with `air` should be immediately followed by the character `p`; thereby returning documents whose metadata _id_ value is `airport`, but not `airline`:

----
REGEXP_CONTAINS(META().id, "^air(?=p)")
----

For information on the expression `^`, see xref:learn:clusters-and-availability/xdcr-regular-expressions.adoc[XDCR Regular Expressions].

Alternatively, _negative_ lookahead might be used to specify that the metadata _id_ that begins with `air` should _not_ be followed by the character `l`; thereby returning documents whose metadata _id_ value is `airport`, but not `airline`:

----
REGEXP_CONTAINS(META().id, "^air(?!l)")
----

=== XDCR Pattern Matching: Comparison with N1QL

The function `REGEXP_CONTAINS` is also supported by N1QL.
Note, however, that N1QL does not support forward lookahead.

N1QL supports a number of pattern-matching functions in addition to `REGEXP_CONTAINS`: see xref:n1ql:n1ql-language-reference/patternmatchingfun.adoc[Pattern-matching Functions].

`META` is one of a group of _reserved words_ used by XDCR Advanced Filtering.
For details, see xref:learn:clusters-and-availability/xdcr-filtering-expressions.adoc#reserved-words[Reserved Words], below.
`META` is also one of a larger group of reserved words used by N1QL.
For details, see the page for N1QL xref:n1ql:n1ql-language-reference/reservedwords.adoc[Reserved Words].

[#checking-for-existence]
== Checking for Existence

The existence of a field can be checked for, by means of the Collection Operator `EXISTS`.
The syntax is as follows:

[cols="1"]
|===
| `EXISTS` ( _expression_ )
|===

For example:

----
EXISTS(country)
----

This returns every document that contains a `country` field.
This would therefore include `airline_10`:

----
{
  "callsign": "MILE-AIR",
  "country": "United States",
  "iata": "Q5",
  "icao": "MLA",
  "id": 10,
  "name": "40-Mile Air",
  "type": "airline"
}
----

=== XDCR Collection Operator: Comparison with N1QL

XDCR Advanced Filtering provides the single Collection Operator, `EXISTS`; which determines whether or not a specified field exists in the body of a document.
N1QL uses `EXISTS` on subclauses; and provides a variety of additional Collection Operators.
For details, see the N1QL page for xref:n1ql:n1ql-language-reference/collectionops.adoc[Collection Operators].

[#using-logical-operators]
== Using Logical Operators

[#using-comparison-operators]
== Using Comparison Operators

[#using-arithmetic-operators]
== Using Arithmetic Operators

[#selecting-fields-and-elements]
== Selecting Fields and Elements

[#handling-dates]
== Handling Dates

[#reserved-words]
== Reserved Words

[#filtering-expression-bnf]
== Filtering Expression BNF

The relationships between available expressions for XDCR Advanced Filtering are expressed in the following table, in _Backus-Naur Form_.

[cols="4,5"]
|===
| Expression | Is Equal To

| AndCondition
| { OpenParens } Condition { "AND" Condition } { CloseParen }

| Condition
| ( [ "NOT" ] Condition ) | Operand

| Operand
| BooleanExpr | ( LHS ( CheckOp | ( CompareOp RHS) ) )

| BooleanExpr
| Boolean | BooleanFuncExpr

| LHS
| ConstFuncExpr | Boolean | Field | Value

| RHS
| ConstFuncExpr | Boolean | Value | Field

| CompareOp
| "=" | "==" | "<>" | "!=" | ">" | ">=" | "<" | "<="

| CheckOp
| ( "IS" [ "NOT" ] ( NULL | MISSING ) )

| Field
| { @"-" } OnePath { "." OnePath } { MathOp MathValue }

| OnePath
| ( PathFuncExpression | StringType ){ ArrayIndex }

| StringType
| @String | @Ident | @RawString | @Char

| ArrayIndex
| "[" @Int "]"

| Value
| @String

| ConstFuncExpr
| ConstFuncNoArg | ConstFuncOneArg | ConstFuncTwoArgs

| ConstFuncNoArg
| ConstFuncNoArgName "(" ")"

| ConstFuncNoArgName
| "PI" | "E"

| ConstFuncOneArg
| ConstFuncOneArgName "(" ConstFuncArgument ")"

| ConstFuncOneArgName
| "ABS" | "ACOS"...

| ConstFuncTwoArgs
| ConstFuncTwoArgsName "(" ConstFuncArgument "," ConstFuncArgument ")"

| ConstFuncTwoArgsName
| "ATAN2" | "POW"

| ConstFuncArgument
| Field | Value | ConstFuncExpr

| ConstFuncArgumentRHS
| Value

| PathFuncExpression
| OnePathFuncNoArg

| OnePathFuncNoArg
| OnePathFuncNoArgName "(" ")"

| MathOp
| @"+" | @"-" | @"*" | @"/" | @"%"

| MathValue
| @Int | @Float

| OnePathFuncNoArgName
| "META"

| BooleanFuncExpr
| BooleanFuncTwoArgs | ExistsClause
|===
