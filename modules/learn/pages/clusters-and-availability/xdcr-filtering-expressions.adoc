= XDCR Filtering Expressions

[abstract]
_XDCR filtering expressions_ allow a document to be included in or excluded from a filtered replication, based on the document's fields and values.

[#understanding-filtering-expressions]
== Understanding Filtering Expressions

XDCR Advanced Filtering _expressions_, applied to the documents within a specified source bucket, allow matches to be made on:

* _id_ and _xattrs_ values, within the document's _metadata_.

* Field-names and values, within the document's _data_, nested to any degree.

Every document on which a match is successfully made is included in the filtered replication.
Other documents are _not_ included.

XDCR filtering expressions constitute a subset of _N1QL_ expressions, with some additions.

Sections on this page list the available expressions, provide examples of their usage, and provide links to documentation for the comparable N1QL expressions.
A list of _reserved words_ is provided.
Additionally, relationships between expressions are listed in in BNF (_Backus-Naur Form_) notation.

Note that examples assume the `travel-sample` bucket to be the source of the filtered replication.
For information on installing this bucket, see xref:manage:manage-settings/install-sample-buckets.adoc[Install Sample Buckets].

XDCR Advanced Filtering can be managed by means of Couchbase Web Console (see xref:manage:manage-xdcr/filter-xdcr-replication.adoc[Filter a Replication]), the CLI (see xref:cli:cbcli/couchbase-cli-xdcr-replicate.adoc[xdcr-replicate]), and the REST API (see xref:rest-api:rest-xdcr-create-replication.adoc[Creating XDCR Replications]).

[#pattern-matching]
== Pattern Matching

Pattern matching is supported with the following syntax:

[cols="1"]
|===
| `REGEXP_CONTAINS` (_expression_, _pattern_)
|===

For example, the following expression specifies `country` as the _expression_, and `"France"` as the pattern:

----
REGEXP_CONTAINS(country, "France")
----

If `travel-sample` is used as the source bucket, every document that contains a field `country` whose value is `"France"` is replicated to the target.
For example, this would include the document `airline_1191`:

----
{
  "callsign": "REUNION",
  "country": "France",
  "iata": "UU",
  "icao": "REU",
  "id": 1191,
  "name": "Air Austral",
  "type": "airline"
}
----

[#mata-data-access]
=== Metadata Access

Each document contains _metadata_, as well as _data_.
Within the metadata, a document's _id_ and _extended attributes_ can be accessed by means of the reserved word `META`, used as part of the the pattern-matching _expression_.

For example, the following expression seeks a match on any document whose metadata _flags_ field has the value `33554432`:

----
REGEXP_CONTAINS(META().flags, 33554432)
----

This would match a number of documents from `travel-sample`, including `airline_10`, whose metadata is as follows:

----
{
  "meta": {
    "id": "airline_10",
    "rev": "1-159642cc11a000000000000002000000",
    "expiration": 0,
    "flags": 33554432,
    "type": "json"
  },
  "xattrs": {}
}
----

_Extended Attributes_ are optionally used to defined application-specific metadata.
The field name is `xattrs`.
In the metadata example shown above, the value is null.
If an extended attribute were defined, such as a `color` field, with a value of `blue`, the appearance would be as follows:

----
  "xattrs": {
    "color": "blue"
  }
----

The extended attribute's value could be filtered and matched with the following expression:

----
REGEXP_CONTAINS(META().xattrs.color, "blue")
----

For information on extended attributes, see xref:learn:data/extended-attributes-fundamentals.adoc[Extended Attributes].

[#lookahead]
=== Lookahead
XDCR Advanced Filtering is supported by _lookahead_.
Lookahead is used to specify a _pattern_, in pattern matching; and permits a match when one specified character or character-sequence:

* Is followed by another specified character or character-sequence.
This is termed _positive_ lookahead.
+
The following syntax is used:
+
[cols="1"]
|===
| _char1_ ( `?=` _char2_ )
|===
+
The specified _char1_ must therefore be located and, for a successful match to be obtained, must be followed by the specified _char2_.

* Is _not_ followed by another specified character or character-sequence.
This is termed _negative_ lookahead.
+
The following syntax is used:
+
[cols="1"]
|===
| _char1_ ( `?!` _char2_ )
|===
+
The specified _char1_ must therefore be located, and, for a successful match to be obtained, must _not_ be followed by the specified _char2_.

Lookahead might therefore be used on the `travel-sample` bucket, to filter documents whose metadata _id_ contains `airport` rather than `airline`, or vice versa.
For example, the following expression uses _positive_ lookahead to specify that the metadata _id_ that begins with `air` should be immediately followed by the character `p`; thereby returning documents whose metadata _id_ value is `airport`, but not `airline`:

----
REGEXP_CONTAINS(META().id, "^air(?=p)")
----

For information on the expression `^`, see xref:learn:clusters-and-availability/xdcr-regular-expressions.adoc[XDCR Regular Expressions].

Alternatively, _negative_ lookahead might be used to specify that the metadata _id_ that begins with `air` should _not_ be followed by the character `l`; thereby returning documents whose metadata _id_ value is `airport`, but not `airline`:

----
REGEXP_CONTAINS(META().id, "^air(?!l)")
----

=== XDCR Pattern Matching: Comparison with N1QL

The function `REGEXP_CONTAINS` is also supported by N1QL.
Note, however, that N1QL does not support forward lookahead.

N1QL supports a number of pattern-matching functions in addition to `REGEXP_CONTAINS`: see xref:n1ql:n1ql-language-reference/patternmatchingfun.adoc[Pattern-matching Functions].

`META` is one of a group of _reserved words_ used by XDCR Advanced Filtering.
For details, see xref:learn:clusters-and-availability/xdcr-filtering-expressions.adoc#reserved-words[Reserved Words], below.
`META` is also one of a larger group of reserved words used by N1QL.
For details, see the page for N1QL xref:n1ql:n1ql-language-reference/reservedwords.adoc[Reserved Words].

[#checking-for-existence]
== Checking for Existence

The existence of a field can be checked for, by means of the Collection Operator `EXISTS`.
The syntax is as follows:

[cols="1"]
|===
| `EXISTS` ( _expression_ )
|===

For example:

----
EXISTS(country)
----

This returns every document that contains a `country` field.
This would therefore include `airline_10`:

----
{
  "callsign": "MILE-AIR",
  "country": "United States",
  "iata": "Q5",
  "icao": "MLA",
  "id": 10,
  "name": "40-Mile Air",
  "type": "airline"
}
----

=== XDCR Collection Operator: Comparison with N1QL

XDCR Advanced Filtering provides the single Collection Operator, `EXISTS`; which determines whether or not a specified field exists in the body of a document.
N1QL uses `EXISTS` on subclauses; and provides a variety of additional Collection Operators.
For details, see the N1QL page for xref:n1ql:n1ql-language-reference/collectionops.adoc[Collection Operators].

[#using-logical-operators]
== Using Logical Operators

XDCR Advanced Filtering provides the Logical Operators `AND`, `OR`, and `NOT`.
See the xref:learn:clusters-and-availability/xdcr-filtering-expressions.adoc##filtering-expression-bnf[Filtering Expression BNF], below, for the syntactic possibilities of these operators.

`AND` can be used to add a required condition to an expression.
For example:

----
REGEXP_CONTAINS(country, "France") AND airportname = "La Teste De Buch"
----

This provides a successful match on any document whose `country` value is `"France"`, and whose `aiportname` value is `"La Test De Buch"`.
This would therefore include the following document in the replication:

----
{
  "airportname": "La Teste De Buch",
  "city": "Arcachon",
  "country": "France",
  "faa": "XAC",
  "geo": {
    "alt": 49,
    "lat": 44.59639,
    "lon": -1.110833
  },
  "icao": "LFCH",
  "id": 1283,
  "type": "airport",
  "tz": "Europe/Paris"
}
----

`OR` can be used to add an alternative condition to an expression.
For example:

----
REGEXP_CONTAINS(country, "France") OR country = "United States"
----

This provides a successful match on any document whose `country` value is either `"France"` or `"United States"`.

`NOT` can be prepended to a condition, to allow a successful match only when the condition is false.
For example:

----
REGEXP_CONTAINS(country, "France") AND NOT airportname = "La Teste De Buch"
----

This provides a successful match on every document that contains the `country` value `"France"`, and contains an `airportname` value that is _not_ `"La Teste De Buch"`.

=== XDCR Logical Operators: Comparison with N1QL

N1QL provides the same Logical Operators as does XDCR Advanced Filtering.
For details, see the N1QL page for xref:n1ql:n1ql-language-reference/logicalops.adoc[Logical Operators].

[#using-comparison-operators]
== Using Comparison Operators

XDCR Advanced Filtering provides the following Comparison Operators:

[cols="4,4,4"]
|===
| `=` _and_ `==`  | `!=` _and_ `&lt;&gt;` | `&gt;`
| `&gt;=` | `&lt;` | `&lt;=`
| `IS NULL` | `IS NOT NULL` | `IS MISSING`
| `IS NOT MISSING` | `IS VALUED` | `IS NOT VALUED`
|===

As this indicates, the tests for equality and inequality are each provided in two versions, to ensure compatibility with different languages.

Note that for purposes of comparison, each field within a document is categorized as one of the following:

* Has a non-_null_ value
* Is specified as _null_
* Is missing a non-_null_ value, and is not specified as _null_

Therefore:

* `NULL` is successfully matched with _null_.
* `IS NOT NULL` is successfully matched when the field either has a value, or is missing a value.
* `IS MISSING` is successfully matched when neither _null_ nor a value is present.
* `IS NOT MISSING` is successfully matched when either _null_ or a value is present.
* `IS VALUED` is successfully matched when a value is present.
* `IS NOT VALUED` is successfully matched with _null_.

For example:

----
REGEXP_CONTAINS(country, "France") AND name != "40-Mile Air"
----

This provides a successful match with every document whose `country` value is `"France"`, and whose `name` value is not `"40-Mile Air"`.
This would include `airline_1191`:

----
{
  "callsign": "REUNION",
  "country": "France",
  "iata": "UU",
  "icao": "REU",
  "id": 1191,
  "name": "Air Austral",
  "type": "airline"
}
----

The following, additional example tests for a _null_ `icao` field, on documents whose `country` value is `United States`:

----
REGEXP_CONTAINS(country, "United States") AND icao IS NULL
----

This returns a number of matches, one of which is `airport_4079`:

----
{
  "airportname": "Orlando",
  "city": "Orlando",
  "country": "United States",
  "faa": "DWS",
  "geo": {
    "alt": 340,
    "lat": 28.398,
    "lon": -81.57
  },
  "icao": null,
  "id": 4079,
  "type": "airport",
  "tz": "America/New_York"
}
----

=== XDCR Comparison Operators: Comparison with N1QL

The Comparison Operators provided by XDCR Advanced Filtering are a subset of those provided by N1QL.
For details, see the N1QL page for xref:n1ql:n1ql-language-reference/comparisonops.adoc[Comparison Operators].

[#selecting-fields-and-elements]
== Selecting Fields and Elements

XDCR Advanced Filtering provides operators for Field Selection, Element Selection, and Array Slicing.

=== Field Selection

The Field Selection Operator is the period: `'.'`
This allows a child-field, within a parent-field, to be specified.
Note that the Field Selection Operator was used to specify the metadata `id` field, in xref:learn:clusters-and-availability/xdcr-filtering-expressions.adoc#mata-data-access[Metadata Access], above.

The following example uses the Field Selection Operator to obtain a match on any document that contains a `country` field with a value of `"United States"`, and also has an `alt` field, within the value of its `geo` field, with a value that is greater than or equal to `6813`.

----
REGEXP_CONTAINS(country, "United States") AND geo.alt >= 6813
----

This returns a number of matches, including `airport_4084`:

----
{
  "airportname": "Telluride",
  "city": "Telluride",
  "country": "United States",
  "faa": "TEX",
  "geo": {
    "alt": 9078,
    "lat": 37.953759,
    "lon": -107.90848
  },
  "icao": "KTEX",
  "id": 4084,
  "type": "airport",
  "tz": "America/Denver"
}
----

=== Element Selection

The Element Selection Operator, which provided for use on arrays, takes the form `[` _n_ `]`, where _n_ is an array-position.

For example, the following matches successfully when a document whose `airline` value is `"AA"` also contains a `schedule` array, whose initial member has a field `flight` with a value of `"UA552"`:

----
REGEXP_CONTAINS(airline, "AA") AND schedule[0].flight = "UA552"
----

This produces a match on document `route_5784`:

----
{
  "airline": "AA",
  "airlineid": "airline_24",
  "destinationairport": "PHL",
  "distance": 153.59665185566308,
  "equipment": "E90 DH3 319",
  "id": 5784,
  "schedule": [{
    "day": 0,
    "flight": "AA679",
    "utc": "22:01:00"
  }, {
    "day": 0,
    "flight": "AA253",
    "utc": "22:29:00"
  }, {
    "day": 1,
    "flight": "AA407",
    "utc": "00:28:00"
  }, {
    "day": 1,
    "flight": "AA966",
    "utc": "17:42:00"
  }, {
    "day": 1,
    "flight": "AA713",
    "utc": "11:33:00"
  }, {
    "day": 1,
    "flight": "AA321",
    "utc": "10:20:00"
  }, {
    "day": 2,
    "flight": "AA297",
    "utc": "12:57:00"
  }, {
    "day": 2,
    "flight": "AA185",
    "utc": "01:33:00"
  }, {
    "day": 3,
    "flight": "AA175",
    "utc": "09:06:00"
  }, {
    "day": 3,
    "flight": "AA878",
    "utc": "19:19:00"
  }, {
    "day": 4,
    "flight": "AA295",
    "utc": "07:44:00"
  }, {
    "day": 5,
    "flight": "AA525",
    "utc": "00:01:00"
  }, {
    "day": 5,
    "flight": "AA335",
    "utc": "20:45:00"
  }, {
    "day": 5,
    "flight": "AA057",
    "utc": "03:40:00"
  }, {
    "day": 5,
    "flight": "AA305",
    "utc": "02:27:00"
  }, {
    "day": 6,
    "flight": "AA016",
    "utc": "19:06:00"
  }, {
    "day": 6,
    "flight": "AA661",
    "utc": "16:35:00"
  }],
  "sourceairport": "LGA",
  "stops": 0,
  "type": "route"
}
----

[#using-arithmetic-operators]
== Using Arithmetic Operators



[#handling-dates]
== Handling Dates

[#reserved-words]
== Reserved Words

[#filtering-expression-bnf]
== Filtering Expression BNF

The relationships between available expressions for XDCR Advanced Filtering are expressed in the following table, in _Backus-Naur Form_.

[cols="4,5"]
|===
| Expression | Is Equal To

| AndCondition
| { OpenParens } Condition { "AND" Condition } { CloseParen }

| Condition
| ( [ "NOT" ] Condition ) | Operand

| Operand
| BooleanExpr | ( LHS ( CheckOp | ( CompareOp RHS) ) )

| BooleanExpr
| Boolean | BooleanFuncExpr

| LHS
| ConstFuncExpr | Boolean | Field | Value

| RHS
| ConstFuncExpr | Boolean | Value | Field

| CompareOp
| "=" | "==" | "<>" | "!=" | ">" | ">=" | "<" | "<="

| CheckOp
| ( "IS" [ "NOT" ] ( NULL | MISSING ) )

| Field
| { @"-" } OnePath { "." OnePath } { MathOp MathValue }

| OnePath
| ( PathFuncExpression | StringType ){ ArrayIndex }

| StringType
| @String | @Ident | @RawString | @Char

| ArrayIndex
| "[" @Int "]"

| Value
| @String

| ConstFuncExpr
| ConstFuncNoArg | ConstFuncOneArg | ConstFuncTwoArgs

| ConstFuncNoArg
| ConstFuncNoArgName "(" ")"

| ConstFuncNoArgName
| "PI" | "E"

| ConstFuncOneArg
| ConstFuncOneArgName "(" ConstFuncArgument ")"

| ConstFuncOneArgName
| "ABS" | "ACOS"...

| ConstFuncTwoArgs
| ConstFuncTwoArgsName "(" ConstFuncArgument "," ConstFuncArgument ")"

| ConstFuncTwoArgsName
| "ATAN2" | "POW"

| ConstFuncArgument
| Field | Value | ConstFuncExpr

| ConstFuncArgumentRHS
| Value

| PathFuncExpression
| OnePathFuncNoArg

| OnePathFuncNoArg
| OnePathFuncNoArgName "(" ")"

| MathOp
| @"+" | @"-" | @"*" | @"/" | @"%"

| MathValue
| @Int | @Float

| OnePathFuncNoArgName
| "META"

| BooleanFuncExpr
| BooleanFuncTwoArgs | ExistsClause
|===
